<!doctype html>
<!--
======================================================================
Warranty Reimbursement: State Law Requirements -- Interactive Program
======================================================================
-->
<html lang="en">
<!-- =========================================================
     FILE: indexv1b.html
     PURPOSE:
       Main Warranty Advisor UI (topics, FAQs, User Notes, admin).
       Assumes loader has already stored parsed Excel context in
       sessionStorage under "we_ctx_json_v1".
     DEPENDENCIES:
       - loaderv1b.html (reads MasterLegalData.xlsx and writes context)
       - Browser support for sessionStorage and localStorage
     HIGH-LEVEL STRUCTURE:
       - <style>     : Base + mode-specific styles
       - <body>      : Layout (header, actions bar, topics, card, notes)
       - <script>    : Core runtime + feature modules (Topics, FAQs,
                       User Notes, Favorites, Admin, printing/actions)
   ========================================================= -->

<!-- =========================================================
     RUNTIME MODULE MAP (main <script> blocks in this file)

     This is a bird’s-eye guide to the major runtime modules.
     It is meant to match the outline in "Program Structure &
     Reorganization Effort" (Word document).

     A) Payload bootstrap + WE / WEApp wiring
        - Reads sessionStorage("we_ctx_json_v1") from the loader.
        - Builds core structures:
            WE.DATA, WE.TOPICS_BY_STATE, WE.FAQS_BY_STATE,
            WE.STATE_NAMES, WE.STATE_REVISION, etc.
        - Establishes window.WE and window.WEApp namespaces.

     B) Shared helpers
        - WE.searchItems(...)  → generic search/filter utility.
        - Global WEApp namespace stub (safe no-op if already defined).

     C) UX helpers
        - Loaded-states badge and active-topic badge (window.WEUX).
        - Small UI helpers that decorate the main layout.

     D) Core UI logic & mode management
        - Tracks CURRENT_MODE:
            "topics", "faq-list", "faq-item", "faq-topics",
            "favorites", "notes", "admin".
        - Renders:
            * Topic pills and topic cards (WEApp.render).
            * FAQ list view, FAQ topics view, single FAQ view.
        - Central printing helpers:
            * buildCardPrintHTML()   → card-only print (topics/FAQ).
            * WEApp.buildStatePrintHTML() → Print All Topics per state.
            * printFaqs()            → Print All FAQs (or filtered list).
        - Wires the main actions bar (Copy / Print / Print All).

     E) FAQ search UI
        - Builds FAQ search box + live filter.
        - Uses WE.searchItems to filter questions/answers/categories.
        - Supports "Print filtered FAQs" by calling printFaqs().

     F) Favorites module (WE.Favorites)
        - LocalStorage-backed favorites list.
        - Captures current view (state + mode + topic/FAQ id + label).
        - Renders the Favorites side panel and handles:
            * Add current view
            * Re-open favorite view
            * Clear/remove favorites

     G) User Notes workspace
        - LocalStorage-backed notes (id, title, body HTML, state, tags).
        - Tags:
            * State codes (from WE.STATE_NAMES)
            * Manufacturers
            * Custom user tags
        - Filters + search over notes.
        - Rich-text-style editing toolbar and special-characters popup.
        - openNotes() / closeNotes() layout integration.
        - Notes-only printing and JSON import/export.

     H) Admin mode & Excel export
        - Admin login dialog and password check from META.
        - WE.ADMIN_MODE flag and admin-only UI (badges, buttons).
        - Topic and FAQ editors.
        - Excel export pipeline:
            * Build updated workbook from WE.DATA/ENTRIES/FAQS.
            * Preserve extra sheets (META, _States, and others).
            * Trigger download of MasterLegalData_UPDATED.xlsx.
        - Tracks when an export/update is needed.

     I) Keyboard shortcuts & glue
        - Topic and FAQ keyboard navigation (arrows, Enter).
        - Admin entry/exit:
            * Shift + click logo
            * Shift + Enter (global, except while typing)
        - Save with Ctrl+Enter / Cmd+Enter inside admin modals.
        - updateAdminExportButtonState(): enable/disable export button
          based on WE.ADMIN_UPDATE_NEEDED.
   ========================================================= -->

<head>
<script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>

    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Warranty Reimbursement: State Law Requirements</title>

<style>
/* =========================================================
   SECTION: Styles (Main App)
   ORDERING:
     1) Base & variables
     2) Global components (buttons, pills, cards, panels, tooltips)
     3) Layout (shell, grids, responsive tweaks)
     4) Mode-specific styles:
        - Topics / FAQ cards
        - FAQ list & FAQ topics
        - Favorites panel
        - User Notes workspace
        - Admin / editors
     5) Print-specific tweaks for on-screen UI (not printHTML output)
   NOTE:
     We will gradually regroup selectors under these headings as we
     refactor. For now, this comment acts as a map to the plan in the
     Word document.
   ========================================================= */

      /* Two-column FAQ list layout */
      .faq-grid .faq-row {
        display: grid;
        grid-template-columns: 7fr 3fr; /* 70% : 30% */
        gap: 14px;
        align-items: start;
        padding: 8px 0;
        border-bottom: 1px dashed #f0f2f7;
        border-radius: 8px;
      }
      .faq-grid .faq-row:hover {
        background: #fafbff;
      }
      .faq-grid .faq-q {
        cursor: pointer;
      }
      .faq-grid .faq-a {
        color: #555;
        font-size: 0.9rem; /* 90% of as body/questions */
        font-weight: 800;
        line-height: 1.35;
      }

      /* Responsive: collapse to one column on narrow widths */
      @media (max-width: 880px) {
        .faq-grid .faq-row {
          grid-template-columns: 1fr;
          gap: 6px;
        }
      }

      /* --- FAQ list + actions --- */
      .faq-list {
        display: flex;
        flex-direction: column;
        gap: 6px;
        margin-top: 8px;
      }
      .faq-item {
        padding: 0.4rem 0.6rem;
        border: 1px solid var(--border);
        border-radius: 8px;
        background: #fff;
        cursor: pointer;
        transition:
          box-shadow 0.15s,
          border-color 0.15s;
      }
      .faq-item:hover {
        box-shadow: 0 0 0 3px rgba(71, 176, 114, 0.18);
        border-color: #b7e4c7;
      }

      /* title inside card when showing a single Q&A */
      .faq-title {
        font-weight: 700;
        margin: 0 0 0.25rem 0;
      }

      :root {
        --pill-bg: #edf7ee; /* light green */
        --pill-text: #2d6a4f;
        --pill-bg-active: #2d6a4f; /* dark green */
        --pill-text-active: #ffffff;
        --pill-border: #b7e4c7;
      }
      #faqMount {
        display: none;
      }
      .topics {
        overflow: visible;
      }

      /* compact green “pills” */
      button.topic-pill {
        padding: 0.34rem 0.56rem;
        margin: 0; 
        border-radius: 8px;
        background: var(--pill-bg);
        color: var(--pill-text);
        border: 1px solid var(--pill-border);
        font-weight: 500;
        line-height: 1.1;
        cursor: pointer;
        user-select: none;

        width: 100%;                        /* fill the grid column */
        text-align: center;                 /* center the label */
        display: inline-flex;               /* vertically center label */ 
        justify-content: center;
        align-items: center;
        min-height: 2.0rem;                 /* tweak between 1.9–2.1 to taste */
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;        
        transition:
          background-color 0.15s,
          color 0.15s,
          box-shadow 0.15s,
          border-color 0.15s;
      }
      button.topic-pill:hover {
        box-shadow: 0 0 0 3px rgba(71, 176, 114, 0.18);
      }
      button.topic-pill.active {
        background: var(--pill-bg-active) !important;
        color: var(--pill-text-active) !important;
        border-color: var(--pill-bg-active) !important;
      }
      button.topic-pill[disabled] {
        opacity: 0.6;
        cursor: not-allowed;
      }

      /* Unified tooltip: any element with data-tip uses the same black bubble */
      [data-tip] {
        position: relative;
      }
      [data-tip]:hover::after {
        content: attr(data-tip);
        position: absolute;
        top: calc(100% + 8px);
        left: 50%;
        transform: translateX(-50%);
        background: #111;
        color: #fff;
        white-space: nowrap;
        padding: 0.35rem 0.55rem;
        border-radius: 6px;
        font-size: 0.85rem;
        z-index: 9999;
        box-shadow: 0 4px 14px rgba(0, 0, 0, 0.2);
      }
      /* While User Notes are open, suppress tooltips so they don't
         visually fight with the notes workspace. */
      body.notes-open [data-tip]:hover::after {
        display: none;
      }

      [data-tip]:hover::before {
        content: "";
        position: absolute;
        top: 100%;
        left: 50%;
        transform: translateX(-50%);
        border: 6px solid transparent;
        border-top-color: #111;
      }

      /* --- FAQ button (under Governing State) --- */
      .faq-area {
        margin-top: 6px;
      }

      button.topic-pill.faq-btn {
        background: var(--pill-bg) !important;
        color: var(--pill-text) !important;
        border: 1px solid var(--pill-border) !important;
        border-radius: 8px;
        padding: 0.5rem 0.9rem;
        margin: 0.1rem 0 0 0;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        width: 100%;
        max-width: 280px;
        font-weight: 600;
        font-size: 0.95rem;
        color: var(--fg, #1f2937) !important;
        letter-spacing: 0.01em;
      }
      button.topic-pill.faq-btn:hover {
        box-shadow: 0 0 0 3px rgba(71, 176, 114, 0.18);
      }
      button.topic-pill.faq-btn.active {
        background: var(--pill-bg-active) !important;
        color: var(--pill-text-active) !important;
        border-color: var(--pill-bg-active) !important;
      }


/* When Notes mode is active */
body.notes-open #notesWorkspace {
  border: 1px solid #bc3737;   /* Worldwide red */
  border-top-width: 2px;
//  box-shadow: 0 0 6px rgba(188,55,55,0.25);  /* soft glow */
}

      /* --- Two-column Topic Grid (FAQs) --- */
      .faq-topic-grid {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 8px 16px;
        margin-top: 8px;
      }
      .faq-topic-link {
        padding: 6px 8px;
        border: 1px solid var(--border, #e3e6ec);
        border-radius: 8px;
        background: #fff;
        cursor: pointer;
        user-select: none;
        transition:
          box-shadow 0.15s,
          border-color 0.15s;
      }
      .faq-topic-link:hover {
        box-shadow: 0 0 0 3px rgba(71, 176, 114, 0.18);
        border-color: #b7e4c7;
      }

/* FAQ admin modal layout */
.admin-faq-main {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.admin-modal-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 2px;
}
.admin-modal-underline {
  width: 100%;
  height: 3px;
  background: #bc3737;   /* brand red */
  border-radius: 2px;
  margin: 4px 0 12px 0;  /* tighten spacing above and below */
}

/* Reuse same look as other admin buttons */
.admin-modal-buttons {
  display: flex;
  gap: 8px;
}
/* Title block holds "Edit FAQ ..." and the assigned categories row */
.admin-modal-title-block {
  display: flex;
  flex-direction: column;
  gap: 4px;
}

/* Assigned categories area under the title */
.admin-faq-assigned {
  margin-top: 0px;
}

/* Container for the little assigned chips */
#adminFaqAssigned {
  display: flex;
  flex-wrap: wrap;
  gap: 6px;
  margin-top: 2px;
}

/* Assigned chip style (read-only badges) */
.faq-assigned-chip {
  display: inline-flex;
  align-items: center;
  padding: 3px 10px;
  border-radius: 999px;
  font-size: 0.8rem;
  background: var(--pill-bg-active);
  color: #fff;
  white-space: nowrap;
}

/* Message when nothing is assigned yet */
.admin-faq-assigned-empty {
  font-size: 0.8rem;
  color: #777;
  font-style: italic;
}

#adminFaqCancelBtn,
#adminFaqSaveBtn {
  padding: 4px 10px;
  font-size: 0.85rem;
  border-radius: 6px;
  border: 1px solid #ccc;
  background: #f6f7fb;
  color: #333;
  cursor: pointer;
}
/* Save button: green when there are unsaved changes, grey otherwise */
#adminFaqSaveBtn {
  border-color: var(--pill-bg-active);
  background: #d4e2d9;     /* light grey-green when disabled */
  color: #666;
}

#adminFaqSaveBtn:not([disabled]) {
  background: var(--pill-bg-active);  /* same dark green as topic pill */
  border-color: var(--pill-bg-active);
  color: #fff;
  cursor: pointer;
}

#adminFaqSaveBtn[disabled] {
  cursor: default;
}

      @media (max-width: 720px) {
        .faq-topic-grid {
          grid-template-columns: 1fr;
        }
      }

      [hidden] {
        display: none !important;
      }
    
</style>
<!-- ========================= Style for Admin Layout ========================= --> 
   <style>
      #adminLoginOverlay {
        position: fixed;
        inset: 0;
        background: transparent; /* stays invisible; purely for blocking clicks */
        z-index: 900;
        display: none;
      }
    </style>

    <!-- ========================= Matching Styles for Card Layout ========================= -->
    <style>
      .card-row {
        margin: 6px 0;
      }
      .card-row .row-label {
        margin: 12px 0 4px;
        font-weight: 700;
      }
      .card-row .row-value {
        display: block;
      }
      .push-grid {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 16px;
      }
      .push-col h3 {
        margin: 0 0 8px 0;
        font-size: 1.05rem;
      }
      .push-col ul {
        margin: 0;
        padding-left: 1.2rem;
      }
      @media (max-width: 700px) {
        .push-grid {
          grid-template-columns: 1fr;
        }
      }
 
</style>

    <!-- ========================= Base Layout Styles ========================= -->
    <style>
      :root {
        --brand-red: #bc3737;
        --green: #2e7d32;
        --ink: #111;
        --muted: #666;
        --pill: #f7f7f7;
        --border: #e4e4e4;
        --card: #ffffff;
      }
      html,
      body {
        margin: 0;
        padding: 0;
      }
      html {
        scrollbar-gutter: stable both-edges;
      }
      body {
        overflow-y: scroll;
      }
      body {
        font-family: system-ui, Arial, sans-serif;
        color: var(--ink);
        background: #fafafa;
      }
      .wrap {
        max-width: 1100px;
        margin: 24px auto;
        padding: 0 16px;
      }
      header {
        display: flex;
        align-items: flex-start;
        justify-content: space-between;
        gap: 12px;
      }
      h1 {
        margin: 0 0 6px 0;
        font-size: 2rem;
        font-weight: 700;
      }
      .brandline {
        height: 4px;
        background: var(--brand-red);
        border-radius: 2px;
        margin: 6px 0 14px 0;
        width: 100%;
      }
 
.topic-help {
  margin-top: 0.35rem;
  font-size: 0.9rem;
  color: #555;
  min-height: 1.4rem;   /* reserve space so layout doesn’t jump */
  line-height: 1.3;
}

     .logo {
      position: relative; 
      min-width: 210px; /* ensure logo plate is wider than 190px buttons */
      }

      .logo img {
      height: 58px;     /* taller logo so buttons feel "under" it */
      }

      header > div:first-child {
        flex: 1 1 auto;
        min-width: 0;
      }

      .notice {
        background: #fff5e6;
        border: 1px solid #ffe1b3;
        color: #5b4a1f;
        padding: 10px 12px;
        border-radius: 10px;
        margin-bottom: 12px;
      }

      .controls {
        display: grid;
        grid-template-columns: 280px 1fr;
        gap: 16px;
        align-items: start;
      }
      .statewrap,
      .topicswrap {
        background: #f9fbf7;
        border: 1px solid #dfe9d9;
        border-radius: 12px;
        padding: 12px;
      }
      .statewrap label,
      .topicswrap label {
        display: block;
        font-weight: 700;
        color: var(--pill-text);
        margin-bottom: 6px;
      }
      .statewrap select {
        width: 100%;
        padding: 10px;
        border: 2px solid #2e7d32;
        border-radius: 8px;
        background: #fff;
        appearance: none;
        background-image:
          linear-gradient(45deg, transparent 50%, #2e7d32 50%),
          linear-gradient(135deg, #2e7d32 50%, transparent 50%);
        background-position:
          calc(100% - 18px) calc(50% - 4px),
          calc(100% - 12px) calc(50% - 4px);
        background-size:
          6px 6px,
          6px 6px;
        background-repeat: no-repeat;
      }

      /* Desktop: fixed 5-column grid */
        .topics {
          display: grid;
          grid-template-columns: repeat(5, minmax(0, 1fr));
          column-gap: 8px;
          row-gap: 6px;
        }

      /* Smaller screens or narrow window: auto-fit */
      @media (max-width: 900px) {
        .topics {
          display: grid;
          grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
          column-gap: 8px;
          row-gap: 6px;
        }
      }

      /* Actions bar: left (FAQ Topics) + right (copy/print/print-all) */
      .actions {
        display: flex;
        justify-content: space-between;
        gap: 8px;
        margin: 10px 0 14px;
        align-items: center;
      }
      .actions-left {
        display: flex;
        gap: 8px;
        align-items: center;
      }
      .actions-right {
        display: flex;
        gap: 8px;
        align-items: center;
      }
      /* When action buttons are disabled (e.g., while User Notes is open),
         keep them visibly present but clearly inactive. */
      .actions-right button:disabled {
        opacity: 0.4;          /* a bit faded, but easy to see */
        cursor: default;
        pointer-events: none;  /* no hover/click interaction */
      }

      .actions button {
        padding: 3px 6px;
        border: 1px solid var(--border);
        border-radius: 8px;
        background: #fff;
        cursor: pointer;
      }
      .actions button:hover {
        filter: brightness(0.98);
      }
 /* When User Notes are open, visually disable the right-side action buttons */
      body.notes-open .actions-right button:disabled {
        opacity: 0.7;
        cursor: default;
        pointer-events: none;
      }
      .card {
        background: var(--card);
        border: 1px solid #e6e6e6;
        border-radius: 12px;
        padding: 16px;
      }
      /* User Notes workspace */
      .notice-inner {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 8px;
        flex-wrap: wrap;
      }
      .notice-left {
        display: flex;
        gap: 4px;
        align-items: baseline;
        flex-wrap: wrap;
      }
      .notice-actions {
        display: flex;
        gap: 8px;
        align-items: center;
      }

      #userNotesBtn {
        padding: 6px 12px;
        border-radius: 999px;
        border: 1px solid #d1d5db; /* neutral gray */
        background: #ffffff;
        color: #111827; /* black text */
        cursor: pointer;
        font-size: 0.8rem;
        font-weight: 600;
      }
      #userNotesBtn:hover {
        background: #f3f4f6;
      }

      /* When notes are open, let the button echo the red workspace accent */
      body.notes-open #userNotesBtn {
        border-color: #bc3737;
        background: #fff5f5;
        color: #bc3737;
      }
      body.notes-open #userNotesBtn:hover {
        background: #ffecec;
      }
        .notes-workspace {
    background: var(--card);
    border: 2px solid #e6e6e6;
    border-radius: 12px;
    padding: 0;
    margin: 16px 0;
    overflow: hidden;            /* Clip inner corners to match radius */
  }

  /* Top header strip for User Notes */
  .notes-ribbon {
    position: relative;            /* anchor for the X button */
    border-bottom: 1px solid #ddd;
  }
/* ---------------------------------------------------------
   MODE STYLES: User Notes workspace
   Covers:
     - Notes ribbon (title, tags, filters)
     - Shared 5-column notes-row grid
     - Notes editor and list layout
     - Special characters popup
   Corresponds to "User Notes workspace" feature module.
   --------------------------------------------------------- */

  .notes-ribbon-accent {
    height: 2px;
    background: var(--brand-red);
    border-radius: 12px 12px 0 0;
    margin: 0; 
  }

  .notes-ribbon-main {
    display: flex;
    justify-content: space-between;
    align-items: center;
    gap: 12px;
    padding: 3px 6px;
    background: #fdf7f7;
    border-top: none;
    flex-wrap: wrap;
  }

  .notes-ribbon-left {
    display: flex;
    align-items: center;
    gap: 8px;
    flex-wrap: wrap;
  }

  .notes-ribbon-right {
    display: flex;
    align-items: center;
    gap: 8px;
  }

  .notes-title-label {
    font-weight: 600;
    margin-right: 4px;
  }

  .notes-ribbon-left button,
  .notes-ribbon-right button,
  .notes-format-group button {
    padding: 3px 6px;
    border: 1px solid var(--border);
    border-radius: 6px;
    background: #fff;
    cursor: pointer;
    font-size: 0.8rem;
  }

  .notes-ribbon-left button:hover,
  .notes-ribbon-right button:hover,
  .notes-format-group button:hover {
    filter: brightness(0.97);
  }

  .notes-ribbon-field {
    font-size: 0.8rem;
    display: flex;
    align-items: center;
    gap: 4px;
  }

  .notes-ribbon-field select,
  .notes-ribbon-field input {
    font-size: 0.8rem;
    padding: 2px 4px;
  }

  .notes-group-label {
    font-size: 0.8rem;
    font-weight: 600;
    margin-right: 4px;
  }

  /* Big X in the far top-right of the notes card */
  .notes-close-btn {
    position: absolute;
    right: 8px;
    top: 4px;
    font-size: 32px;
    line-height: 18px;
    width: 26px;
    height: 26px;
    text-align: center;
    border: none;
    background: none;
    cursor: pointer;
  }
  /* Shared 5-column grid for Tags and Filters rows
     Col 1: toolbar (filters row only)
     Col 2: "Tags:" / "Filters:"
     Col 3: State
     Col 4: OEM
     Col 5: Custom/User tags
  */
  .notes-row {
    display: grid;
    grid-template-columns: 440px 60px 170px 170px 170px;
    column-gap: 8px;
    align-items: center;
    padding: 4px 10px 2px 10px;
    background: #f7f7f7;
    font-size: 0.8rem;
  }

  /* Group labels always live in column 2 */
  .notes-row .notes-group-label {
    grid-column: 2;
    font-weight: 600;
    justify-self: start;
  }

  /* Field groups share column alignment */
  .notes-row .notes-field-state  { grid-column: 3; }
  .notes-row .notes-field-oem    { grid-column: 4; }
  .notes-row .notes-field-custom { grid-column: 5; }

  .notes-row .notes-ribbon-field {
    display: flex;
    align-items: center;
    gap: 4px;
  }

  .notes-row .notes-ribbon-field select,
  .notes-row .notes-ribbon-field input {
    height: 28px;
    padding: 2px 6px;
    font-size: 0.85rem;
    box-sizing: border-box;
    width: 100%;
  }

  /* Filters row: toolbar lives in column 1 */
  .notes-filters-row .notes-toolbar {
    grid-column: 1;
    display: flex;
    flex-wrap: wrap;
    gap: 4px;
    justify-content: flex-start;
  }

  /* Bottom stripe that holds the filters row */
  .notes-ribbon-bottom {
    border-top: 1px solid #eee;
    background: #f7f7f7;
    padding-bottom: 4px;
  }

  /* Special characters pop-up stays the same */
  .notes-special-char {
    position: relative;
    display: inline-block;
  }

  .notes-special-menu {
    position: absolute;
    top: 110%;
    left: 0;
    background: #fff;
    border: 1px solid #ddd;
    border-radius: 6px;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
    padding: 4px;
    z-index: 1000;
    display: flex;
    flex-wrap: wrap;
    gap: 2px;
  }

  .notes-special-menu button {
    min-width: 24px;
    padding: 2px 4px;
    font-size: 0.8rem;
  }

  /* The rest of the notes layout (list + editor) stays as-is */
  .notes-main {
    display: flex;
    gap: 12px;
    padding: 8px 10px 10px 10px;
    flex-wrap: wrap;
  }

      .notes-main {
        @media print {
          body.notes-printing header,
          body.notes-printing .notice,
          body.notes-printing .controls,
          body.notes-printing .actions,
          body.notes-printing #card,
          body.notes-printing #page-footer {
            display: none !important;
          }
          body.notes-printing #notesWorkspace {
            border: none;
            box-shadow: none;
            margin: 0;
          }
        }

        display: flex;
        gap: 12px;
        padding: 8px 10px 10px 10px;
        flex-wrap: wrap;
      }
      .notes-list {
        flex: 0 0 260px;
        max-width: 260px;
        border-right: 1px solid #eee;
        padding-right: 8px;
        max-height: 420px;
        overflow: auto;
      }
      .notes-editor {
        flex: 1 1 300px;
        min-width: 0;
        display: flex;
        flex-direction: column;
        gap: 6px;
      }
      .notes-title-input {
        font-size: 1rem;
        padding: 6px 8px;
        border-radius: 6px;
        border: 1px solid #ccc;
      }
      .notes-body-editor {
        min-height: 220px;
        border: 1px solid #ccc;
        border-radius: 6px;
        padding: 8px;
        background: #fff;
        overflow: auto;
      }
      .notes-body-editor[contenteditable="true"]:empty:before {
        content: attr(data-placeholder);
        color: #999;
      }
      .notes-list-empty {
        font-size: 0.8rem;
        color: #777;
        padding: 4px 2px;
      }
      .notes-list-item {
        width: 100%;
        text-align: left;
        border: 1px solid transparent;
        border-radius: 6px;
        padding: 6px 6px;
        margin-bottom: 4px;
        background: #fafafa;
        cursor: pointer;
        font-size: 0.8rem;
      }
      .notes-list-item:hover {
        border-color: #ddd;
        background: #f2f2f2;
      }
      .notes-list-item.active {
        border-color: var(--brand-red);
        background: #fff;
      }
      .notes-list-title {
        font-weight: 600;
        margin-bottom: 2px;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }
      .notes-list-meta {
        font-size: 0.8rem;
        color: #666;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
/* Tags & Filters rows: 4-column grid:
   [label] [State] [OEM] [User tags] */
.notes-tags-row,
.notes-filter-row {
  display: grid;
  grid-template-columns: 175px 175px 175px; 
  column-gap: 12px;
  align-items: center;
  padding: 4px 10px;
  background: #fdf7f7;
  font-size: 0.8rem;
}

/* "Tags:" / "Filters:" label in the first column */
.notes-tags-row .notes-group-label,
.notes-filter-row .notes-group-label {
  font-weight: 600;
}

/* Each field (State / OEM / User tags) laid out as label + control inline */
.notes-tags-row .notes-ribbon-field,
.notes-filter-row .notes-ribbon-field {
  display: flex;
  align-items: center;
  gap: 4px;
}

/* Make all dropdowns/inputs match in size */
.notes-tags-row .notes-ribbon-field select,
.notes-tags-row .notes-ribbon-field input,
.notes-filter-row .notes-ribbon-field select {
  height: 28px;
  padding: 2px 6px;
  font-size: 0.85rem;
  box-sizing: border-box;
  width: 100%;
}

/* Small vertical separation between the two rows, if you like */
.notes-tags-row {
  margin-top: 3px;
  margin-bottom: 2px;
}
.notes-filter-row {
  margin-top: 0;
  margin-bottom: 3px;
  width: max-content;   /* shrink to just the grid content */
  margin-left: auto;    /* push the whole row to the right */
}

/* "Filters:" label */
.notes-filter-row .notes-group-label {
  font-weight: 600;
  margin-right: 8px;
}

/* Each filter: label + control inline */
.notes-filter-row .notes-ribbon-field {
  display: flex;
  align-items: center;
  gap: 4px;
}

/* Match filter control widths to tag control widths */
.notes-filter-row .notes-ribbon-field select {
  min-width: 150px;  /* should match the tags row min-width above */
  height: 28px;
  padding: 2px 6px;
  font-size: 0.85rem;
  box-sizing: border-box;
}


      @media (max-width: 800px) {
        .notes-main {
          flex-direction: column;
        }
        .notes-list {
          flex: 1 1 auto;
          max-width: none;
          border-right: none;
          border-bottom: 1px solid #eee;
          padding-right: 0;
          padding-bottom: 8px;
        }
      }

      .muted {
        color: var(--muted);
        font-size: 0.95rem;
      }
      #meta {
  color: #2e7d32;
  margin-bottom: 8px;
}
/* Make the topic section headers in the main card use the same green */
#hdr-summary,
#hdr-admin,
#hdr-push,
#hdr-cites,
#hdr-excerpts {
  color: var(--pill-text);
}

      h2 {
        margin: 14px 0 6px;
        font-size: 1.15rem;

      }
 
     .card h2 {
        color: var(--pill-text);
      }

      ul {
        margin: 6px 0 10px 18px;
      }
      blockquote {
        border-left: 3px solid #ddd;
        padding-left: 10px;
        margin: 8px 0;
      }

      @media print {
  /* Hide all the chrome above the card */
  header,
  .controls,
  .actions,
  .notice,
  .logo,
  #notesWorkspace {
    display: none !important;
  }
        .wrap {
          max-width: 100%;
          margin: 0;
          padding: 0;
        }
        body {
          background: #fff;
        }
        h1 {
          font-size: 1.5rem;
          line-height: 1.15;
        }
      }
      @media print {
        #versionBanner,
        .note {
          display: none !important;
        }
      }
    </style>
    <style>
      /* Reusable rule for the Favorites divider; swap color to your exact brand red */
      .fav-rule {
        height: 3px;
        background: #bc3737;
        border-radius: 2px;
        margin: -2px 0 8px;
      }
    </style>
    <style>
      /* Star inside the Favorites launcher; compatible with [data-tip] tooltips */
      #favBtn .fav-star {
        display: inline-block;
        margin-right: 6px;
        font-size: 0.95em;
        line-height: 1;
        /* optional color: */
        /* color:#f0b400; */
      }

    </style>
<style>
      /* Admin topic editing: pencil icon + modal */

      .admin-edit-icon {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        margin-left: 8px;
        padding: 2px 6px;
        font-size: 0.9rem;
        font-weight: 600;
        color: #c62828;                 /* branded red-ish */
        border-radius: 999px;           /* pill shape */
        border: 1px solid #ffcdd2;      /* light red border */
        background: #fff5f5;            /* very pale red background */
        cursor: pointer;
      }
      .admin-edit-icon:hover {
        background: #ffe3e0;
        color: #b71c1c;
        border-color: #ef9a9a;
      }
      .admin-faq-edit::after {
        content: " Edit";
        font-size: 0.8rem;
        font-weight: 600;
        margin-left: 4px;
      }

#adminFaqModal .admin-modal-panel {
  max-width: 1040px;          /* roughly card width */
}

      #adminEditModal[hidden] {
        display: none !important;
      }
      #adminEditModal {
        position: fixed;
        inset: 0;
        z-index: 2000;
        display: flex;
        align-items: center;
        justify-content: center;
      }
#adminFaqModal {
  position: fixed;
  inset: 0;
  z-index: 2000;
  display: flex;
  align-items: center;
  justify-content: center;
}
      .admin-modal-backdrop {
        position: absolute;
        inset: 0;
        background: rgba(0, 0, 0, 0.3);
      }
      .admin-modal-panel {
        position: relative;
        background: #ffffff;
        border-radius: 10px;
        padding: 14px 16px 12px 16px;
        max-width: 900px;
        width: 100%;
        max-height: 80vh;
        display: flex;
        flex-direction: column;
        gap: 8px;
        box-shadow: 0 14px 40px rgba(15, 23, 42, 0.3);
        border: 1px solid #e3e6ec;
        z-index: 1;
      }
      #adminEditTitle {
        margin: 0 0 4px 0;
        font-size: 1.05rem;
      }
      .admin-modal-main {
        display: grid;
        grid-template-columns: minmax(0, 1.2fr) minmax(0, 1fr);
        gap: 10px;
        margin-top: 4px;
      }
      .admin-modal-label {
       font-weight: 700;         /* bold */
       font-size: 1rem;          /* larger and more readable */
       color: #333;              /* darker gray for contrast */
       margin: 8px 0 6px;       /* a bit more breathing room */
      }
      #adminEditText {
        width: 100%;
        min-height: 220px;
        resize: vertical;
        padding: 6px 8px;
        font-family: system-ui, Arial, sans-serif;
        font-size: 0.9rem;
        border-radius: 6px;
        border: 1px solid #ccc;
        box-sizing: border-box;
      }
      /* FAQ admin fields: match topic editor look */
      textarea.admin-textarea {
        width: 100%;
        min-height: 80px;
        resize: vertical;
        padding: 6px 8px;
        font-family: system-ui, Arial, sans-serif;
        font-size: 0.9rem;
        border-radius: 6px;
        border: 1px solid #ccc;
        box-sizing: border-box;
      }
/* Question and Short Answer are always short; keep them compact */
#adminFaqQuestion.admin-textarea,
#adminFaqShortAnswer.admin-textarea {
  min-height: 52px; /* ~2 lines plus a little padding */
}
/* Legal Authority tends to be long; give it more room by default */
#adminFaqLegalAuthority.admin-textarea {
  min-height: 170px; /* slightly smaller than topic editor height */
}
/* Add spacing between "Categories" header and the chips */
#adminFaqCategories {
  margin-top: 8px;    /* or 10–12px if you want more space */
}

      input.admin-input {
        width: 100%;
        padding: 6px 8px;
        font-family: system-ui, Arial, sans-serif;
        font-size: 0.9rem;
        border-radius: 6px;
        border: 1px solid #ccc;
        box-sizing: border-box;
      }

      #adminEditPreview {
        border-radius: 6px;
        border: 1px solid #e1e1e1;
        padding: 6px 8px;
        font-size: 0.9rem;
        background: #fafafa;
        max-height: 260px;
        overflow: auto;
      }
      .admin-modal-footer {
        margin-top: 8px;
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 8px;
        flex-wrap: wrap;
      }
      .admin-modal-mode {
        font-size: 0.85rem;
        display: flex;
        align-items: center;
        gap: 10px;
      }
      .admin-modal-mode label {
        display: inline-flex;
        align-items: center;
        gap: 3px;
        cursor: pointer;
      }
      .admin-modal-buttons {
        display: flex;
        gap: 8px;
      }
      .admin-modal-buttons button {
        padding: 4px 10px;
        border-radius: 6px;
        border: 1px solid #ccc;
        background: #fff;
        cursor: pointer;
        font-size: 0.85rem;
      }
      .admin-modal-buttons button#adminEditSave {
        border-color: #2e7d32;
        background: #2e7d32;
        color: #fff;
      }
      .admin-modal-buttons button#adminEditSave:hover {
        filter: brightness(0.97);
      }
      .admin-modal-buttons button#adminEditCancel:hover {
        filter: brightness(0.97);
      }

      @media (max-width: 800px) {
        .admin-modal-main {
          grid-template-columns: 1fr;
        }
        #adminEditPreview {
          max-height: 180px;
        }
      }
/* FAQ modal category chips */
.faq-cat-chip {
  border-radius: 999px;
  padding: 4px 10px;
  font-size: 12px;
  border: 1px solid #d0d7e2;
  background: #f8fafc;
  cursor: pointer;
  white-space: nowrap;
}

.faq-cat-chip.selected {
  background: var(--pill-bg-active);
  color: #fff;
  border-color: var(--pill-bg-active);
}
.admin-faq-main h2 {
  margin-top: 0;
  margin-bottom: 16px;
}
.admin-faq-cat-count {
  font-size: 12px;
  color: #666;
}
.admin-faq-meta {
  margin-top: 8px;
  font-size: 13px;
  color: #666;
}
.admin-faq-cats-header span:first-child {
  font-weight: 700;
  font-size: 1rem;
  color: #333;
}
.admin-faq-cat-hint {
  margin-top: 6px;
  font-size: 12px;
  color: #666;
}

.admin-faq-cat-hint.warning {
  color: #b14b4b; /* a muted red */
}
    


</style>

  </head>
  <body>
    <div class="wrap">
      <header>
        <div>
          <h1>Warranty Reimbursement: State Law Requirements</h1>
          <div class="brandline"></div>
        </div>
        <div class="logo">
             <img src="thetruckpeople-logo.png"
             alt="Worldwide Equipment"
             id="weLogo"
             style="cursor:pointer;"
             />
<script>
(function () {
  const logo = document.getElementById("weLogo");
  if (!logo) return;
    /**
     * Admin module (header-anchored, module-local)
     * -------------------------------------------
     * Scope:
     *   - Local to this IIFE; does not attach new functions directly to window.
     *
     * Responsibilities:
     *   - showAdminLoginUI(): render a password prompt in place of the logo.
     *   - enterAdminMode(): switch into admin mode and show admin controls.
     *   - exitAdminMode(): switch back to normal user mode and restore layout.
     *
     * Entry points:
     *   - Shift+click on the logo (weLogo).
     *   - Shift+Enter global keyboard shortcut (when not typing in a field).
     *
     * Dependencies:
     *   - window.WE.ADMIN_PASSWORD (string, set elsewhere).
     *   - window.WE.ADMIN_MODE (boolean, tracks admin on/off).
     *   - window.updateAdminExportButtonState (global helper; optional).
     *   - window.exportUpdatedExcel (global Excel export function).
     *   - window.showFaqItem / WEApp.render for re-rendering content.
     */

  // ---------------------------------------
  // SHOW ADMIN LOGIN BOX IN PLACE OF LOGO
  // ---------------------------------------
  function showAdminLoginUI() {
    // If we're already in admin mode, do nothing
    if (window.WE && WE.ADMIN_MODE) return;

    // If a login box already exists, just focus its input
    const existing = document.getElementById("adminLoginBox");
    if (existing) {
      const input = document.getElementById("adminPwInput");
      if (input) input.focus();
      return;
    }

    const parent = logo.parentElement;
    if (!parent) return;

    // --- Ensure overlay exists and show it ---
    let overlay = document.getElementById("adminLoginOverlay");
    if (!overlay) {
      overlay = document.createElement("div");
      overlay.id = "adminLoginOverlay";
      document.body.appendChild(overlay);
    }
    overlay.style.display = "block";

    // Hide logo while the login card is visible
    logo.style.display = "none";

    // Create a compact admin login "card" that matches the app's style
    const box = document.createElement("div");
    box.id = "adminLoginBox";

    // Card styling: narrow, vertical, brand-aligned
    box.style.display = "flex";
    box.style.flexDirection = "column";
    box.style.alignItems = "stretch";
    box.style.gap = "6px";
    box.style.minWidth = "210px";         // similar to logo/admin button width
    box.style.padding = "8px 10px";
    box.style.background = "#f9fbf7";     // same feel as state/topic panels
    box.style.border = "1px solid #dfe9d9";
    box.style.borderRadius = "10px";
    box.style.boxShadow = "0 4px 10px rgba(0,0,0,0.08)";
    box.style.position = "absolute";
    box.style.right = "0";

    // Move the card up so it's above the yellow bar / closer to the top.
    // You can tweak this number a bit (-28px, -36px, etc.) to taste.
    box.style.top = "-32px";

    // Make sure it floats above the overlay and the rest of the UI
    box.style.zIndex = "1000";

    box.innerHTML = `
      <div style="
        font-size: 11px;
        font-weight: 600;
        color: var(--brand-red);
        text-transform: uppercase;
        letter-spacing: 0.04em;
      ">
        Admin login
      </div>
      <input
        id="adminPwInput"
        type="password"
        placeholder="Admin password"
        maxlength="20"
        style="
          padding: 6px 8px;
          font-size: 13px;
          border-radius: 6px;
          border: 2px solid #2e7d32;
          width: 100%;
          box-sizing: border-box;
        "
      />
      <div style="
        display: flex;
        justify-content: flex-end;
        gap: 6px;
        margin-top: 2px;
      ">
        <button
          id="adminPwCancel"
          type="button"
          style="
            padding: 4px 10px;
            font-size: 12px;
            border-radius: 6px;
            border: 1px solid #d1d5db;
            background: #f3f4f6;
            color: #374151;
            cursor: pointer;
          "
        >
          Cancel
        </button>
        <button
          id="adminPwSubmit"
          type="button"
          style="
            padding: 4px 12px;
            font-size: 12px;
            border-radius: 6px;
            border: 1px solid var(--pill-bg-active);
            background: var(--pill-bg-active);
            color: #ffffff;
            cursor: pointer;
          "
        >
          Enter
        </button>
      </div>
    `;

    parent.appendChild(box);

    const inputEl = document.getElementById("adminPwInput");
    if (inputEl) inputEl.focus();

    // Helper to close the login card + overlay
    function closeLoginCard() {
      const card = document.getElementById("adminLoginBox");
      if (card) card.remove();
            // If we are already in Admin mode, keep the logo hidden.
      // Otherwise (cancel / bad password), restore it.
      try {
        if (window.WE && WE.ADMIN_MODE) {
          logo.style.display = "none";
        } else {
          logo.style.display = "";
        }
      } catch (e) {
        // Fallback: if anything goes wrong, restore the logo
        logo.style.display = "";
      }

      const ov = document.getElementById("adminLoginOverlay");
      if (ov) ov.style.display = "none";
    }

    document.getElementById("adminPwSubmit").onclick = () => {
      const pw = document.getElementById("adminPwInput").value.trim();
      if (pw === (window.WE && WE.ADMIN_PASSWORD)) {
        enterAdminMode();
        closeLoginCard();
      } else {
        alert("Incorrect password");
        if (inputEl) {
          inputEl.focus();
          inputEl.select();
        }
      }
    };

    document.getElementById("adminPwCancel").onclick = () => {
      closeLoginCard();
    };
    // --- Keyboard behavior: Enter = submit, Esc = cancel ---
    const keyHandler = (evt) => {
      if (evt.key === "Enter") {
        // Only submit if the login card is open
        if (document.getElementById("adminLoginBox")) {
          document.getElementById("adminPwSubmit").click();
          evt.preventDefault();
        }
      }
      if (evt.key === "Escape") {
        if (document.getElementById("adminLoginBox")) {
          document.getElementById("adminPwCancel").click();
          evt.preventDefault();
        }
      }
    };

// [GLOBAL][KEYBOARD SHORTCUTS]
// Purpose:
//   - Provide power-user shortcuts for admin access and print actions.
// Shortcuts:
//   • Shift+Enter   → Toggle admin login window.
//   • Ctrl+P        → In card view, triggers "Print / Save Topic/FAQ".
//   • Esc           → Closes admin login, notes modal, or FAQ item if open.
// Notes:
//   - Must check focus target to avoid interfering with typing within inputs.
//   - Lives at global scope because multiple modules rely on these behaviors.
    document.addEventListener("keydown", keyHandler);

    // Remove key handler when card closes
    const removeKeys = () => {
      document.removeEventListener("keydown", keyHandler);
    };

    // Patch closeLoginCard() so it also removes keyboard listeners
    const originalClose = closeLoginCard;
    closeLoginCard = () => {
      removeKeys();
      originalClose();
    };

    // Clicking anywhere on the overlay also cancels the login card
    overlay.onclick = () => {
      closeLoginCard();
    };
  }


  // ---------------------------------------
  // ENTER ADMIN MODE
  // ---------------------------------------
   /**
    * enterAdminMode (module-local)
    * -----------------------------
    * - Marks global flag WE.ADMIN_MODE = true.
    * - Hides the logo and converts its container into:
    *     - A green “Download Updated Excel” button (calls window.exportUpdatedExcel).
    *     - A red “ADMIN MODE (click to exit)” badge (calls exitAdminMode).
    * - Clears topic help text so the admin UI isn’t cluttered.
    * - Initializes the admin export button’s enabled/disabled state
    *   via window.updateAdminExportButtonState(), if available.
    * - Re-renders either:
    *     - The current FAQ (when in single-FAQ mode), **or**
    *     - The current topic card,
    *   so that admin edit icons appear in the content area.
    */
  function enterAdminMode() {
    WE.ADMIN_MODE = true;

// Clear topic help when entering Admin mode
  var help = document.getElementById("topicHelp");
  if (help) help.textContent = "";

    // Remove login box
    const login = document.getElementById("adminLoginBox");
    if (login) login.remove();

    // Hide logo while in admin mode
    logo.style.display = "none";
    const parent = logo.parentElement;
    if (!parent) return;

    // Make the logo container a vertical stack of buttons,
    // aligned to the right, nudged down toward the red brand line.
    parent.style.display = "flex";
    parent.style.flexDirection = "column";
    parent.style.alignItems = "flex-end";
    parent.style.gap = "6px";
    // Adjust this number a little (8–16) if you want to fine-tune
    // the vertical alignment with the red line:
    parent.style.marginTop = "2px";

    // Common button styling: same width + font size
    const BUTTON_WIDTH = "190px";
    const BUTTON_FONT_SIZE = "13px";

    // -----------------------------------
    // GREEN: Export Updated Excel (top)
    // -----------------------------------
    const exportBtn = document.createElement("button");
    exportBtn.id = "adminExportBtn";
    exportBtn.type = "button";
    exportBtn.textContent = "Download Updated Excel";

    exportBtn.style.padding = "4px 12px";
    exportBtn.style.fontSize = BUTTON_FONT_SIZE;
    exportBtn.style.borderRadius = "6px";
    // Match darker green of selected topic-pill:
    exportBtn.style.border = "1px solid var(--pill-bg-active)";
    exportBtn.style.background = "var(--pill-bg-active)";
    exportBtn.style.color = "#ffffff";
    exportBtn.style.cursor = "pointer";
    exportBtn.style.width = BUTTON_WIDTH;

    exportBtn.addEventListener("click", function () {
      if (typeof window.exportUpdatedExcel === "function") {
        window.exportUpdatedExcel();
      } else {
        alert("Exporter is not available.");
      }
    });

    parent.appendChild(exportBtn);

 // Initialize its enabled/disabled state and tooltip
    if (typeof window.updateAdminExportButtonState === "function") {
      window.updateAdminExportButtonState();
    }
 
    // -----------------------------------
    // RED: Admin badge / exit (bottom)
    // -----------------------------------
    const badge = document.createElement("button"); // behave like a button
    badge.id = "adminModeBadge";
    badge.type = "button";
    badge.textContent = "ADMIN MODE (click to exit)";

    badge.style.padding = "4px 12px";
    badge.style.fontSize = BUTTON_FONT_SIZE;
    badge.style.borderRadius = "6px";
    // Match brandline red:
    badge.style.border = "1px solid var(--brand-red)";
    badge.style.background = "var(--brand-red)";
    badge.style.color = "#ffffff";
    badge.style.cursor = "pointer";
    badge.style.width = BUTTON_WIDTH;

    badge.onclick = exitAdminMode;

    parent.appendChild(badge);
    // After admin UI is in place, re-render the current view so edit icons appear
    try {
      const stateSel = document.getElementById("stateSel");
      const stateKey = String(
        (stateSel && stateSel.value) || "KY"
      ).toUpperCase();

      // If we were on a FAQ when entering admin mode,
      // re-render that FAQ; otherwise re-render the current topic.
      if (
        window.CURRENT_MODE === "faq-item" &&
        window.WE &&
        WE.CURRENT_FAQ_ITEM &&
        typeof window.showFaqItem === "function"
      ) {
        window.showFaqItem(stateKey, WE.CURRENT_FAQ_ITEM);
      } else if (window.WEApp && typeof WEApp.render === "function") {
        const topicKey =
          (window.WE && WE.CURRENT_TOPIC) || "Topic1_Title";
        WEApp.render(stateKey, topicKey, null);
      }
    } catch (e) {
      console.warn("Admin mode initial re-render failed:", e);
    }

  }
 
 
// ---------------------------------------
// EXIT ADMIN MODE
// ---------------------------------------
/**
 * exitAdminMode (module-local)
 * ----------------------------
 * - Clears WE.ADMIN_MODE and closes any open admin editors:
 *     - Topic editor modal
 *     - FAQ editor modal
 * - Removes:
 *     - The red ADMIN MODE badge
 *     - The green export button
 *     - Any leftover login UI
 * - Restores the logo container’s layout/spacing back to normal.
 * - Re-renders the current view (FAQ item or topic card) so that
 *   admin-only icons disappear from the UI.
 * - Finally, shows the logo again.
 */
function exitAdminMode() {
  window.WE = window.WE || {};
  WE.ADMIN_MODE = false;

  // Close FAQ editor, if open
  if (typeof window.closeAdminFaqModal === "function") {
    window.closeAdminFaqModal();
  } else {
    const faqModal = document.getElementById("adminFaqModal");
    if (faqModal) faqModal.hidden = true;
  }

  // Close topic editor, if you have one
  if (typeof window.closeAdminEditModal === "function") {
    window.closeAdminEditModal();
  }

  // Remove the red ADMIN MODE badge and buttons
  const badge = document.getElementById("adminModeBadge");
  if (badge) badge.remove();

  const login = document.getElementById("adminLoginBox");
  if (login) login.remove();

  const exportBtn = document.getElementById("adminExportBtn");
  if (exportBtn) exportBtn.remove();

  // Restore the logo container layout
  const parent = logo.parentElement;
  if (parent) {
    parent.style.display = "";
    parent.style.flexDirection = "";
    parent.style.alignItems = "";
    parent.style.gap = "";
    parent.style.marginTop = "";
  }

  // Re-render the current view so admin-only icons disappear
  try {
    const stateSel = document.getElementById("stateSel");
    const stateKey =
      (stateSel && stateSel.value) ||
      (window.WE && (WE.CURRENT_STATE || WE.DEFAULT_STATE)) ||
      "KY";

    // If we were viewing a single FAQ, re-render that FAQ only
    if (
      window.CURRENT_MODE === "faq-item" &&
      window.WE &&
      WE.CURRENT_FAQ_ITEM &&
      typeof window.showFaqItem === "function"
    ) {
      window.showFaqItem(stateKey, WE.CURRENT_FAQ_ITEM);
    } else if (window.WEApp && typeof WEApp.render === "function") {
      // Otherwise re-render the current topic card
      const topicKey =
        (window.WE && WE.CURRENT_TOPIC) || "Topic1_Title";
      WEApp.render(stateKey, topicKey, null);
    }
  } catch (e) {
    console.warn("Admin exit re-render failed:", e);
  }

  // Restore logo visibility
  logo.style.display = "";
}

  // ---------------------------------------
  // TRIGGERS
  // ---------------------------------------

  // SHIFT + CLICK on the logo
  logo.addEventListener("click", (evt) => {
    if (evt.shiftKey) {
      showAdminLoginUI();
    }
  });

  // SHIFT + ENTER anywhere — but:
  // - not while typing into inputs / textareas / contenteditable
  // - not if already in admin mode
  document.addEventListener("keydown", (evt) => {
    if (!(evt.shiftKey && evt.key === "Enter")) return;

    if (window.WE && WE.ADMIN_MODE) return;

    const active = document.activeElement;
    const tag = active && active.tagName;
    const isTyping =
      tag === "INPUT" ||
      tag === "TEXTAREA" ||
      (active && active.isContentEditable);

    if (isTyping) return;

    showAdminLoginUI();
  });
})();
</script>

        </div>
      </header>

      <div class="notice">
        <div class="notice-inner">
          <div class="notice-left">
            <span id="beta-label">Beta Version</span><span id="beta-num"></span>
          </div>
          <div class="notice-actions">
            <button
              id="userNotesBtn"
              type="button"
              title="Open User Notes workspace"
            >
              User Notes
            </button>
          </div>
        </div>
      </div>

      <!-- Controls -->
      <div class="controls">
        <div class="statewrap">
          <label for="stateSel">Governing State</label>
          <select id="stateSel"></select>
<div
  class="faq-area"
  data-tip="View the full FAQ list for this governing state"
>
  <button id="faqBtn" type="button" class="topic-pill faq-btn">
    Frequently Asked Questions
  </button>
</div>
        </div>

<div class="topicswrap">
  <label>Topics</label>
  <div id="topicBtns" class="topics"></div>
  <div id="topicHelp" class="topic-help"></div>
</div>
      </div>

      <!-- Actions: left + right -->
      <div class="actions">
        <div class="actions-left">
          <button id="faqTopicsBtn" title="Browse FAQs by topic">
            FAQ Topics
          </button>
        </div>
        <div class="actions-right">
          <button id="copyBtn" title="Copy the current card text">
            Copy Card
          </button>
          <button id="printBtn" title="Print or save this card as PDF">
            Print / Save Topic
          </button>
          <button id="printAllBtn" title="Print everything for this view">
            Print All
          </button>
        </div>
      </div>

<!-- User Notes workspace -->
<div id="notesWorkspace" class="notes-workspace" hidden>
  <div class="notes-ribbon">
    <div class="notes-ribbon-accent"></div>
    <div class="notes-ribbon-main">
      <div class="notes-ribbon-left">
        <span class="notes-title-label">User Notes</span>
        <button id="notesNewBtn" type="button">New</button>
        <button id="notesSaveBtn" type="button">Save</button>
        <button id="notesDeleteBtn" type="button">Delete</button>
        <button id="notesPrintBtn" type="button" title="Print or save this note as PDF">
          Print Note
        </button>
        <button id="notesExportBtn" type="button" title="Download this note as a JSON file">
          Export Note File
        </button>
        <button id="notesImportBtn" type="button" title="Import a note file into this app">
          Import Note File
        </button>
      </div>
      <div class="notes-ribbon-right">
        <button
          id="notesCloseBtn"
          type="button"
          class="notes-close-btn"
          aria-label="Close notes"
        >
          &times;
        </button>
      </div>
    </div>
  </div>

  <!-- Row 1: Tags -->
  <div class="notes-row notes-tags-row">
    <span class="notes-group-label">Tags:</span>

    <label class="notes-ribbon-field notes-field-state">
      State
      <select id="noteStateTag"></select>
    </label>

    <label class="notes-ribbon-field notes-field-oem">
      OEM
      <select id="noteManufacturerTag"></select>
    </label>

    <label class="notes-ribbon-field notes-field-custom">
      Custom
      <input
        id="noteOtherTagsInput"
        type="text"
        placeholder="Comma-separated tags"
      />
    </label>
  </div>

  <div class="notes-ribbon-bottom">
    <!-- Row 2: toolbar + Filters -->
    <div class="notes-row notes-filters-row">
      <!-- Column 1: formatting toolbar -->
      <div class="notes-toolbar">
        <button type="button" class="notes-format-btn" data-cmd="bold"><strong>B</strong></button>
        <button type="button" class="notes-format-btn" data-cmd="italic"><em>I</em></button>
        <button type="button" class="notes-format-btn" data-cmd="underline">
          <span style="text-decoration: underline">U</span>
        </button>
        <span class="notes-separator"></span>
        <button type="button" class="notes-format-btn" data-cmd="insertUnorderedList">&bull; List</button>
        <button type="button" class="notes-format-btn" data-cmd="insertOrderedList">1. List</button>
        <span class="notes-separator"></span>
        <button type="button" class="notes-format-btn" data-cmd="justifyLeft">&#8676;</button>
        <button type="button" class="notes-format-btn" data-cmd="justifyCenter">&#8212;</button>
        <button type="button" class="notes-format-btn" data-cmd="justifyRight">&#8677;</button>
        <span class="notes-separator"></span>
        <button type="button" class="notes-format-btn" data-cmd="indent">&rarr;</button>
        <button type="button" class="notes-format-btn" data-cmd="outdent">&larr;</button>
        <span class="notes-separator"></span>
        <div class="notes-special-char">
          <button type="button" id="notesSpecialCharBtn">Ω</button>
          <div id="notesSpecialCharMenu" class="notes-special-menu" hidden>
            <button type="button" data-char="§">§</button>
            <button type="button" data-char="¶">¶</button>
            <button type="button" data-char="–">–</button>
            <button type="button" data-char="—">—</button>
            <button type="button" data-char="•">•</button>
            <button type="button" data-char="≤">≤</button>
            <button type="button" data-char="≥">≥</button>
            <button type="button" data-char="≠">≠</button>
            <button type="button" data-char="±">±</button>
          </div>
        </div>
      </div>

      <!-- Columns 2–5: Filters -->
      <span class="notes-group-label">Filters:</span>

      <label class="notes-ribbon-field notes-field-state">
        State
        <select id="notesStateFilter"></select>
      </label>

      <label class="notes-ribbon-field notes-field-oem">
        OEM
        <select id="notesManufacturerFilter"></select>
      </label>

      <label class="notes-ribbon-field notes-field-custom">
        Custom
        <select id="notesTagFilter"></select>
      </label>
    </div>
  </div>

  <div class="notes-main">
    <div class="notes-list" id="notesList"></div>
    <div class="notes-editor">
      <input
        id="noteTitleInput"
        class="notes-title-input"
        type="text"
        placeholder="Note title"
      />
      <div
        id="noteBody"
        class="notes-body-editor"
        contenteditable="true"
        data-placeholder="Type your note here..."
      ></div>
    </div>
  </div>
</div>

      <!-- Card -->
      <div id="card" class="card">
        <div id="faqMount"></div>
        <div id="meta" class="muted"></div>

        <!-- Legacy section headers/containers (kept; we populate the unified body below) -->
        <h2 id="hdr-summary"></h2>
        <div id="summary"></div>
        <h2 id="hdr-admin"></h2>
        <ul id="checklist"></ul>
        <h2 id="hdr-push"></h2>
        <div id="pushbacks"></div>
        <h2 id="hdr-cites"></h2>
        <ul id="cites"></ul>
        <h2 id="hdr-excerpts"></h2>
        <div id="excerpts"></div>
      </div>
    </div>

    <!-- =================== Libraries / Payload bootstrap =================== -->
    <!-- ===================================================================== -->
    <!-- 1) PAYLOAD BOOTSTRAP: build WE, WE_DATA, STATE names, FAQ grouping    -->
    <!-- ===================================================================== -->
<!-- =========================================================
     SCRIPT MODULE: Admin Mode & Excel Export
     RESPONSIBILITIES:
       - Secure admin access (password from META, login UI)
       - Toggle WE.ADMIN_MODE flag
       - Admin-only UI:
           * Badges, controls for editing topics / FAQs
       - Excel Export:
           * Build updated workbook with edits
           * Preserve META, _States, and extra sheets from loader
           * Ensure correct date formatting and state revisions
       - Exit behavior:
           * exitAdminMode() removes badges, modals, and restores layout
           * Re-renders current topic or FAQ item to clear admin icons
       - Triggers:
           * Shift+click logo
           * Shift+Enter (except while typing in inputs/textarea/editor)
     TIES TO DOC:
       "Feature modules → Admin" and "Excel update" section.
   ========================================================= -->
<!-- ADMIN MODE INITIALIZATION -->
<script>
// =========================================================
      // CORE NAMESPACE & ADMIN FLAGS
      // ---------------------------------------------------------
      // - Ensures window.WE exists (global namespace).
      // - Declares admin-related flags:
      //       WE.ADMIN_MODE            → is admin mode active?
      //       WE.ADMIN_PASSWORD        → set from loader META.adminPassword
      //       WE.ADMIN_UPDATE_NEEDED   → are there unsaved admin edits?
      // - On DOMContentLoaded, copies META.adminPassword into
      //   WE.ADMIN_PASSWORD if available.
      // =========================================================
      window.WE = window.WE || {};
      window.WE.ADMIN_MODE = false;
      window.WE.ADMIN_PASSWORD = "";  // filled after loader runs
      window.WE.ADMIN_UPDATE_NEEDED = false;  // no unsaved admin edits yet
      document.addEventListener("DOMContentLoaded", () => {
        // Pull admin password from META after sessionStorage has been restored
        try {
          if (window.WE && WE.META && WE.META.adminPassword) {
            WE.ADMIN_PASSWORD = WE.META.adminPassword;
          }
        } catch(e) {
          console.warn("Admin PW load error:", e);
        }
      });
</script>
<script>
// =========================================================
      // DATA LOADING & CONTEXT RECONSTRUCTION
      // ---------------------------------------------------------
      // SOURCE: Loader (loaderv1b.html) writes a JSON context into
      //         sessionStorage under key "we_ctx_json_v1".
      //
      // RESPONSIBILITIES:
      // - Read and parse that context (ctx).
      // - Populate global WE/WE_DATA structures used by the UI:
      //       WE_DATA             → normalized topics/rows entries
      //       WE.STATE_NAMES      → code → full name
      //       WE.STATE_REVISION   → last legal update per state
      //       WE.STATES           → list from _States sheet (if present)
      //       WE.TOPICS, WE.TOPIC_TIPS, WE.TOPIC_TIPS_BY_ID
      //       WE.META / WE_META   → metadata from _Meta sheet
      //       WE.FAQS_BY_STATE    → FAQs grouped by state code/name
      // - Preserve original ctx on window.WE_CTX for Admin exports.
      // - Provide compatibility aliases (WE_DATA → WE.DATA) for older code.
      // =========================================================
      (function () {
        try {
          var raw = sessionStorage.getItem("we_ctx_json_v1");
          if (!raw) return;
          var ctx = JSON.parse(raw);
          window.WE_CTX = ctx; // NEW: keep full context for editing/saving
          window.__RAW_ROWS = Array.isArray(ctx.ROWS) ? ctx.ROWS : [];
          if (!ctx) return;

          window.WE = window.WE || {};
          window.WE_DATA = ctx.ENTRIES || [];

          // state names map (code -> full name)
          if (ctx.STATE_NAMES) window.WE.STATE_NAMES = ctx.STATE_NAMES;
          if (ctx.STATE_REVISION) window.WE.STATE_REVISION = ctx.STATE_REVISION;
          if (ctx.STATES) window.WE.STATES = ctx.STATES;

          // topics and topic tips
          if (Array.isArray(ctx.TOPIC_DEFS)) window.WE.TOPICS = ctx.TOPIC_DEFS;
          if (ctx.TOPIC_TIPS_BY_ID)
            window.WE.TOPIC_TIPS_BY_ID = ctx.TOPIC_TIPS_BY_ID;
          if (ctx.TOPIC_TIPS) window.WE.TOPIC_TIPS = ctx.TOPIC_TIPS;

          // meta
          if (ctx.META) {
            window.WE = window.WE || {};
            window.WE.META = ctx.META;
            window.WE_META = ctx.META; // alias for older code
          }

          // state name lookup from _States (optional)
          (function () {
            const getStates = () =>
              window.WE && Array.isArray(window.WE.STATES)
                ? window.WE.STATES
                : [];
            const cache = new Map();
            window.stateNameFromKey = function (k) {
              const key = String(k || "")
                .trim()
                .toUpperCase();
              if (!key) return "";
              if (cache.has(key)) return cache.get(key);
              const rows = getStates();
              for (const r of rows) {
                const ab = String(
                  r.abbr ??
                    r.code ??
                    r.Abbrev ??
                    r.Abbreviation ??
                    r.ABBR ??
                    r.key ??
                    r.id ??
                    "",
                )
                  .trim()
                  .toUpperCase();
                if (ab && ab === key) {
                  const name = String(
                    r.name ?? r.state ?? r.label ?? r.title ?? r.full ?? key,
                  ).trim();
                  cache.set(key, name || key);
                  return name || key;
                }
              }
              for (const r of rows) {
                const n = String(
                  r.name ?? r.state ?? r.label ?? r.title ?? r.full ?? "",
                ).trim();
                if (n && n.toUpperCase() === key) {
                  cache.set(key, n);
                  return n;
                }
              }
              cache.set(key, key);
              return key;
            };
          })();

          // _Rows canon map
          if (Array.isArray(ctx.ROWS)) {
            function k(o, t) {
              const want = String(t).replace(/\s+/g, "").toLowerCase();
              for (const key in o) {
                if (!Object.prototype.hasOwnProperty.call(o, key)) continue;
                const norm = String(key).replace(/\s+/g, "").toLowerCase();
                if (norm === want) return key;
              }
              return undefined;
            }
            function yes(v) {
              if (v === true || v === 1) return true;
              const s = String(v ?? "")
                .trim()
                .toLowerCase();
              return s === "yes" || s === "y" || s === "true" || s === "1";
            }
            window.WE.ROWS = ctx.ROWS.map((r) => {
              const idKey = k(r, "RowID") ?? "id";
              const lblKey = k(r, "UI Label") ?? "label";
              const ordKey = k(r, "Order") ?? "order";
              const rinbKey =
                k(r, "RenderinBody") ??
                k(r, "Render in Body") ??
                k(r, "RenderInBody") ??
                k(r, "RenderinBody ") ??
                "renderInBody";
              const pdKey =
                k(r, "Preferred Delimiter") ?? k(r, "Preferred Delimite");
              const hdrKey = k(r, "HeaderFor") ?? "headerFor";

              const id = r[idKey];
              const lbl = r[lblKey] ?? id;
              const ordN = Number(r[ordKey]);
              const ord = Number.isFinite(ordN) ? ordN : 999999;

              return {
                id: String(id || ""),
                label: String(lbl || ""),
                order: ord,
                renderInBody: yes(
                  rinbKey in r
                    ? r[rinbKey]
                    : (r.renderInBody ??
                        r.RenderinBody ??
                        r["Render in Body"] ??
                        r["RenderinBody "]),
                ),
                preferredDelimiter: String(r[pdKey] ?? ""),
                headerFor: String(r[hdrKey] ?? ""),
              };
            });
          }

          // FAQs grouped by state (code + full name)
          if (Array.isArray(ctx.FAQS)) {
            window.WE.FAQS = ctx.FAQS;
            var nameToCode = {};
            if (ctx.STATE_NAMES) {
              Object.keys(ctx.STATE_NAMES).forEach(function (code) {
                var name = (ctx.STATE_NAMES[code] || "")
                  .toString()
                  .trim()
                  .toUpperCase();
                if (name) nameToCode[name] = code.toUpperCase();
              });
            }
            var grouped = {};
            ctx.FAQS.forEach(function (f) {
              var raw = (f.state || "").toString().trim();
              if (!raw) return;
              var up = raw.toUpperCase();
              var code = up.length === 2 ? up : nameToCode[up] || up;
              var full =
                ctx.STATE_NAMES && ctx.STATE_NAMES[code]
                  ? ctx.STATE_NAMES[code].toString().trim().toUpperCase()
                  : up;
              (grouped[code] = grouped[code] || []).push(f);
              (grouped[full] = grouped[full] || []).push(f);
            });
            window.WE.FAQS_BY_STATE = grouped;
          }

          // compatibility
          if (window.WE_DATA && !window.WE.DATA)
            window.WE.DATA = window.WE_DATA;
        } catch (e) {
          console.error("Payload bootstrap failed:", e);
        }
      })();
    </script>
    <!-- ============================================================== -->
    <!-- 2) SHARED SEARCH HELPER (WE.searchItems)                       -->
    <!-- ============================================================== -->
    <script>
  // [MODULE START] FAQ Search UI
  // =========================================================
  // [MODULE][LOCAL]
  // Purpose:
  //   - Provide a search box and live count for FAQs.
  //   - Filter FAQs (by question, answer, categories) using WE.searchItems.
  //   - Update the FAQ list view to show only matching results.
  //
  // Scope:
  //   - All functions here are LOCAL to this IIFE; nothing is attached
  //     directly to window.*. The module works by wiring DOM events.
  //
  // Dependencies:
  //   - #faqMount        : container where FAQ list view is rendered.
  //   - #faqSearchInput  : text input for "Search FAQs".
  //   - #faqCount        : label showing "# FAQs" after filtering.
  //   - window.getFaqsByState(stateCode)
  //   - WE.searchItems(arr, query, fields)
  //
  // Behavior:
  //   - On each keystroke in the search box:
  //       * Recomputes the filtered FAQ list.
  //       * Updates the count label.
  //       * Rebuilds the FAQ list markup in #faqMount.
  // =========================================================
      // =========================================================
      // CORE UTILITY: WE.searchItems (global search helper)
      // ---------------------------------------------------------
      // - Pure function: no DOM dependencies.
      // - Used by FAQ search and any future search/filter features.
      // - Safe to call from any mode once WE is available.
      // =========================================================

// [GLOBAL UTILITY] WE.searchItems
// ---------------------------------------------------------
// Purpose:
//   Simple case-insensitive multi-field search helper.
//   Accepts:
//       arr  → array of objects (items)
//       query  → search string
//       fields → array of field names (e.g., ["question","answer"])
// Behavior:
//   - Lowercases haystack + needle.
//   - Keeps items where ANY listed field contains the text.
// Dependencies:
//   - None (pure utility).
// Consumers:
//   - FAQ list filtering
//   - Topic-scoped FAQ search
//   - (Future) global search bar (if added)
// ---------------------------------------------------------
      window.WE = window.WE || {};
      if (!window.WE.searchItems) {
        /**
         * @param {Array<object>} arr      The collection to search
         * @param {string}        query    The raw user query
         * @param {Array<string>} fields   Keys to search (e.g., ['question','answer','categories'])
         * @returns {Array<object>}        Filtered array
         */
 
       window.WE.searchItems = function (arr, query, fields) {
          const q = (query || "").trim().toLowerCase();
          if (!q) return arr;
          return arr.filter((obj) =>
            fields.some((key) => {
              let v = obj?.[key];
              if (Array.isArray(v)) v = v.join(" ");
              return String(v ?? "")
                .toLowerCase()
                .includes(q);
            }),
          );
        };
      }
    </script>
    <!-- Global NS holder -->
    <script>
      // =========================================================
      // CORE NAMESPACE: WEApp
      // ---------------------------------------------------------
      // - Provides a shared home for app-level functions:
      //       WEApp.render(...)
      //       WEApp.buildStatePrintHTML(...)
      //       WEApp.updateRightActionsForMode(...)
      // - This stub guarantees the object exists before other
      //   modules attach methods to it.
      // =========================================================
      window.WEApp = window.WEApp || {};
    </script>


<!-- =========================================================
     SCRIPT MODULE: Favorites
     RESPONSIBILITIES:
       - Store favorites in localStorage
       - Provide WE.Favorites API:
           * addCurrent()
           * clearAll()
           * open() (navigate to favorite)
           * ensureUI() (attach panel to DOM/actions bar)
       - Render Favorites side panel w/ sorted list per state/type
       - Handle "Add current", "Clear all", and trash/remove actions
       - Close panel when clicking outside, re-open via Favorites button
     TIES TO DOC:
       "Feature modules → Favorites" and part of
       "Functional Actions" (Favorites section).
   ========================================================= -->

<script>
      // [MODULE START] Favorites (WE.Favorites)
      // =========================================================
      // [MODULE][GLOBAL]
      // Favorites (localStorage) module
      // ---------------------------------------------------------
      // - Lives under window.WE as WE.Favorites.
      // - Non-invasive: reuses existing renderers (topics/FAQ/favorites),
      //   and drives navigation by calling your existing open/render
      //   functions (e.g., showFaqItem, WEApp.render).
      //
      // GLOBAL API EXPOSED:
      //   WE.Favorites.addCurrent()  → Save the current view as a favorite
      //   WE.Favorites.clearAll()    → Remove all favorites from storage
      //   WE.Favorites.open(v)       → Navigate UI to a favorite view
      //   WE.Favorites.ensureUI()    → Ensure Favorites button + panel exist
      //
      // INTERNALS (LOCAL TO MODULE):
      //   - load(), save()
      //   - normalizeId(), resolveStateKey(), viewId(), getCurrentView()
      //   - removeAt(), removeByViewId()
      //   - sortFavoritesView(), _favStateCode(), _favTypeRank(), _faqNumber()
      //   - renderPanel(), show(), hide(), toggle()
      //
      // PERSISTENCE:
      //   - Uses localStorage with a simple JSON array of favorite views.
      // =========================================================
      window.WE = window.WE || {};
      WE.Favorites = (function () {
 
        // [MODULE CONST][LOCAL]
        // KEY:
        //   localStorage key where the favorites array is stored as JSON.
        //   Bump the suffix (v1 → v2) if you ever change the schema.
       const KEY = "we_favorites_v1"; // bump if you ever change schema

        // [PERSISTENCE][LOCAL]
        // load():
        //   Reads favorites from localStorage under KEY.
        //   - Returns [] on any error (malformed JSON, missing key, etc.).
       function load() {
          try {
            return JSON.parse(localStorage.getItem(KEY) || "[]");
          } catch {
            return [];
          }
        }
 
        // [PERSISTENCE][LOCAL]
        // save(list):
        //   Serializes and writes the favorites array back to localStorage.
        //   - Overwrites the previous value for KEY.
       function save(list) {
          localStorage.setItem(KEY, JSON.stringify(list));
        }

        // [NORMALIZE][LOCAL]
        // normalizeId(s):
        //   Produces a stable, uppercase identifier that strips punctuation
        //   and whitespace, keeping only A–Z, digits, and hyphen.
        //   - Used when comparing IDs across different representations.
        const normalizeId = (s) =>
          String(s || "")
            .toUpperCase()
            .replace(/[^A-Z0-9-]/g, "") // strip dots/spaces etc.
            .trim();

        // [NORMALIZE][LOCAL]
        // resolveStateKey(val):
        //   Accepts either a 2-letter code ("KY") or a full state name
        //   ("KENTUCKY") and returns the canonical code if known.
        //   - Uses WE.FAQS_BY_STATE and WE.STATE_NAMES as hints.
        const resolveStateKey = (val) => {
          const raw = String(val || "")
            .trim()
            .toUpperCase();
          const byState = window.WE && WE.FAQS_BY_STATE ? WE.FAQS_BY_STATE : {};
          if (byState[raw]) return raw; // already a 2-letter code that exists

          const names = window.WE && WE.STATE_NAMES ? WE.STATE_NAMES : {};
          // Find code by matching full name (e.g., 'KENTUCKY' -> 'KY')
          for (const code in names) {
            const full = String(names[code] || "")
              .trim()
              .toUpperCase();
            if (full === raw) return code;
          }
          return raw; // fallback (won't crash)
        };


        // [VIEW ID][LOCAL]
        // viewId(v):
        //   Computes a logical identifier for a favorite:
        //     state + mode + topic + faqId  (separated by "|").
        //   - Used to prevent duplicates and remove items reliably.
        function viewId(v) {
          return [v.state, v.mode, v.topic || "", v.faqId || ""].join("|");
        }

        // [CONTEXT][LOCAL]
        // getCurrentView():
        //   Captures the current UI state as a minimal descriptor:
        //     - state (from #stateSel)
        //     - mode  (from window.CURRENT_MODE)
        //     - topic / faqId depending on active view
        //     - label (user-facing text shown in the Favorites panel)
        //   This object is what gets saved in WE.Favorites.
        function getCurrentView() {
          const state = String(
            document.getElementById("stateSel")?.value || "KY",
          ).toUpperCase();
          const mode = String(window.CURRENT_MODE || "topics");

          if (mode === "faq-item") {
            const cur = window.WE?.CURRENT_FAQ_ITEM || {};
            let faqId = cur?.id;

            if (!faqId) {
              const mount = document.getElementById("faqMount");
              faqId = mount?.getAttribute("data-faq-id") || faqId;
            }
            if (!faqId) {
              const t =
                document.querySelector("#faqMount .faq-title")?.textContent ||
                "";
              const m = t.match(/\b[A-Z]{2}-?Q\d+\b/);
              if (m) faqId = m[0];
            }

            const label = String(faqId || "").trim() || "FAQ";
            return {
              state,
              mode: "faq-item",
              faqId: String(faqId || ""),
              label,
            };
          }

          if (mode === "faq-topics") {
            const sname = (WE.STATE_NAMES && WE.STATE_NAMES[state]) || state;
            return {
              state,
              mode: "faq-topics",
              label: `FAQ Topics — ${sname}`,
            };
          }

          if (mode === "faq-list") {
            // Distinguish between the full list and a category-filtered list
            const mount = document.getElementById("faqMount");
            const cat = mount?.getAttribute("data-faq-category");
            const sname = (WE.STATE_NAMES && WE.STATE_NAMES[state]) || state;

            if (cat) {
              return {
                state,
                mode: "faq-category",
                category: String(cat),
                label: `${cat} — ${sname}`,
              };
            }
            return { state, mode: "faq-list", label: `FAQs — ${sname}` };
          }

          // topics (card)
          const active = document.querySelector(
            "#topicBtns .topic-pill.active",
          );
          const topic = active?.getAttribute("data-topic") || "Topic1_Title";
          const tLabel = active?.textContent?.trim() || topic;
          const sname = (WE.STATE_NAMES && WE.STATE_NAMES[state]) || state;
          return {
            state,
            mode: "topics",
            topic,
            label: `${tLabel} — ${sname}`,
          };
        }


        // [GLOBAL API][LOCAL IMPLEMENTATION]
        // addCurrent():
        //   Called via WE.Favorites.addCurrent().
        //   - Reads the current view descriptor from getCurrentView().
        //   - If the view is a single FAQ, tries to:
        //       * Look up the FAQ question text (getFaqsByState).
        //       * Build a friendly label like "TN-Q3 — <question>".
        //   - Prepends the favorite if it is not already present.
        //   - Returns the updated list.
        function addCurrent() {
          const v = getCurrentView();
          // BEGIN: ensure descriptive label when saving a single FAQ (e.g., "TN-Q3 — <question>")
          try {
            // Detect state & faq id from the current view
            const st =
              (v && (v.state || v.stateCode)) ||
              document.getElementById("stateSel")?.value ||
              "";
            const faqId = (v && (v.id || v.faqId || v.faqID)) || "";

            // Heuristic: treat as single-FAQ favorite if explicitly typed or id looks like "TN-Q3"
            const isFaq =
              String(v?.type || "").toLowerCase() === "faq" ||
              /^([A-Z]{2})-Q\d+$/i.test(String(faqId || v?.label || ""));

            if (isFaq) {
              // Look up the question text for this FAQ
              const arr =
                typeof getFaqsByState === "function"
                  ? getFaqsByState(st) || []
                  : [];
              const obj = arr.find(
                (x) =>
                  String(x.id || "").toUpperCase() ===
                  String(faqId || "").toUpperCase(),
              );
              const q = obj ? obj.question || obj.q || "" : "";

              if (q) {
                const idNorm = faqId || (obj && obj.id) || "";
                // Set a user-friendly label for the Favorites panel
                v.label = idNorm + " — " + q; // <-- This is what renderPanel() shows
                // Normalize a couple of fields (harmless if already set)
                v.id = idNorm;
                v.state = st;
                v.type = "faq";
              }
            }
          } catch (e) {
            /* no-op */
          }
          // END: ensure descriptive label

          const list = load();
          const id = viewId(v);
          if (!list.some((x) => viewId(x) === id)) {
            list.unshift({ ...v, ts: Date.now() }); // newest on top
            save(list);
          }
          return list;
        }


        // [INTERNAL MUTATION][LOCAL]
        // removeAt(index):
        //   Removes the favorite at a specific array index and saves.
        //   - Used only by the Favorites panel rendering logic.
        function removeAt(index) {
          const list = load();
          list.splice(index, 1);
          save(list);
          return list;
        }

        // [GLOBAL API][LOCAL IMPLEMENTATION]
        // clearAll():
        //   Called via WE.Favorites.clearAll().
        //   - Wipes all favorites from localStorage (no undo).
        //   - Returns an empty array.
        function clearAll() {
          save([]);
          return [];
        }

        // [GLOBAL API][LOCAL IMPLEMENTATION]
        // open(v):
        //   Called via WE.Favorites.open(v).
        //   - Navigates the main UI to the favorite view `v`:
        //       * Ensures the correct state is selected.
        //       * Dispatches state change if necessary.
        //       * Based on v.mode, reuses existing functions like:
        //         - showFaqItem(...) for FAQ favorites
        //         - WEApp.render(...) for topic favorites.
        //   - All navigation is done by calling existing UI renderers.
        function open(v) {
          if (!v || !v.state) return;

          // Resolve canonical state code (e.g., "KENTUCKY" -> "KY")
          const stKey = resolveStateKey(v.state);

          // Update the dropdown and detect if state changed
          const stateSel = document.getElementById("stateSel");
          const prevVal = stateSel ? stateSel.value : null;
          const changed = !!stateSel && prevVal !== stKey;
          if (stateSel) stateSel.value = stKey;

          // Helper: fire state change, then run fn after the UI settles
          const fireChangeThen = (fn) => {
            if (changed && stateSel) {
              stateSel.dispatchEvent(new Event("change", { bubbles: true }));
              setTimeout(fn, 0);
            } else {
              fn();
            }
          };

          // ===== 1) Single FAQ =====
          if (v.mode === "faq-item") {
            fireChangeThen(() => {
              const arr =
                typeof window.getFaqsByState === "function"
                  ? window.getFaqsByState(stKey)
                  : [];
              if (!Array.isArray(arr) || arr.length === 0) {
                alert(
                  `This favorite is for ${v.state}. That state's FAQs are not loaded in this session.`,
                );
                return;
              }
              // Strict letters+digits normalizer (handles hyphen/en-dash/period/etc.)
              const normalizeId = (s) =>
                String(s || "")
                  .toUpperCase()
                  .replace(/[^A-Z0-9]/g, "")
                  .trim();

              let item = null;

              // 1) Use explicit faqId if present
              if (v.faqId) {
                const wanted = normalizeId(v.faqId);
                item = arr.find((x) => normalizeId(x.id) === wanted);
              }

              // 2) Back-compat: if label looks like an id, use it
              if (!item && v.label && /^[A-Z]{2}-?Q\d+$/i.test(v.label)) {
                const wanted = normalizeId(v.label);
                item = arr.find((x) => normalizeId(x.id) === wanted);
              }

              // 3) Very old favorites: fall back to question text
              if (
                !item &&
                v.label &&
                !/^[A-Z]{2}Q\d+$/i.test(normalizeId(v.label))
              ) {
                const q = v.label.replace(/^FAQ:\s*/, "").trim();
                item =
                  arr.find((x) => String(x.question || "").trim() === q) ||
                  arr.find((x) =>
                    String(x.question || "").includes(q.slice(0, 40)),
                  );
              }

              if (item) {
                if (typeof window.showFaqItem === "function")
                  window.showFaqItem(stKey, item);
                return;
              }
              if (typeof window.showFaqList === "function")
                window.showFaqList(stKey);
            });
            return;
          }

          // ===== 2) Full FAQ list =====
          if (v.mode === "faq-list") {
            window.CURRENT_MODE = "faq-list";
            if (window.WEUX && WEUX.updateActiveTopicBadge)
              WEUX.updateActiveTopicBadge();
            fireChangeThen(() => {
              if (typeof window.showFaqList === "function")
                window.showFaqList(stKey);
            });
            return;
          }

          // ===== 3) FAQ Topics (categories grid) =====
          if (v.mode === "faq-topics") {
            window.CURRENT_MODE = "faq-topics";
            if (window.WEUX && WEUX.updateActiveTopicBadge)
              WEUX.updateActiveTopicBadge();
            fireChangeThen(() => {
              if (typeof window.showFaqTopics === "function")
                window.showFaqTopics(stKey);
              else if (typeof window.showFaqList === "function")
                window.showFaqList(stKey);
            });
            return;
          }

          // ===== 4) Category-filtered FAQ list =====
          if (v.mode === "faq-category" && v.category) {
            // Ensure we land in the topic-scoped list for this category
            window.CURRENT_MODE = "faq-list";
            if (window.WEUX && WEUX.updateActiveTopicBadge)
              WEUX.updateActiveTopicBadge();
            fireChangeThen(() => {
              if (typeof window.showFaqsForTopic === "function")
                window.showFaqsForTopic(stKey, v.category);
              else if (typeof window.showFaqList === "function")
                window.showFaqList(stKey);
            });
            return;
          }

          // ===== 5) Topic card (legacy/topic favorites) =====
          // Put app in "topics" before change so onchange renders topics, not FAQ list
          window.CURRENT_MODE = "topics";
          fireChangeThen(() => {
            const sel = document.querySelector(
              `#topicBtns .topic-pill[data-topic="${v.topic}"]`,
            );
            if (sel) {
              sel.click();
              return;
            }
            if (typeof window.WEApp?.render === "function") {
              window.WEApp.render(stKey, v.topic || "Topic1_Title", null);
            }
          });
        }

        // --- Lightweight panel UI (dropdown) ---
        function escapeHtml(s) {
          return String(s ?? "").replace(
            /[&<>"]/g,
            (m) => ({ "&": "&amp;", "<": "&lt;", ">": "&gt;" })[m] || m,
          );
        }
        function setTip(el, tip) {
          if (!el) return;
          el.setAttribute("data-tip", tip);
          el.setAttribute("aria-label", tip);
          el.removeAttribute("title");
        }

        // One-time migration of static titles in the actions bar to data-tip
        document.addEventListener("DOMContentLoaded", () => {
          [
            "faqTopicsBtn",
            "copyBtn",
            "printBtn",
            "printAllBtn",
            "favBtn",
          ].forEach((id) => {
            const el = document.getElementById(id);
            if (!el) return;
            const t = el.getAttribute("title");
            if (t) setTip(el, t);
          });
        });


        // [GLOBAL API][LOCAL IMPLEMENTATION]
        // ensureUI():
        //   Called via WE.Favorites.ensureUI().
        //   - Ensures there is a Favorites button in the left actions bar.
        //   - Inserts or reorders the button so it appears before "FAQ Topics".
        //   - Creates the dropdown panel element (#favPanel) and attaches:
        //       * click handlers for opening/closing the panel
        //       * a document-level click handler to close when clicking outside.
        function ensureUI() {
          const left = document.querySelector(".actions-left");
          if (!left) return;

          const existingFav = left.querySelector("#favBtn");
          if (existingFav) {
            // Ensure order every time
            const faqTopicsBtn =
              left.querySelector("#faqTopicsBtn") ||
              left.querySelector('[data-role="faq-topics"]') ||
              Array.from(left.querySelectorAll("button")).find(
                (b) => b.textContent.trim() === "FAQ Topics",
              );

            if (faqTopicsBtn) left.insertBefore(existingFav, faqTopicsBtn);
            return; // we’re done; no need to recreate the button
          }

          const btn = document.createElement("button");
          btn.id = "favBtn";
          btn.innerHTML =
            '<span class="fav-star" aria-hidden="true">★</span><span class="fav-label">Favorites</span>';
          btn.setAttribute("data-tip", "View and manage Favorites"); // black tooltip
          btn.setAttribute("aria-label", "View and manage Favorites");
          btn.setAttribute("data-role", "favorites");
          btn.removeAttribute("title"); // no native tooltip
          left.appendChild(btn);
          // Move Favorites before "FAQ Topics"
          const faqTopicsBtn =
            left.querySelector("#faqTopicsBtn") ||
            left.querySelector('[data-role="faq-topics"]') ||
            Array.from(left.querySelectorAll("button")).find(
              (b) => b.textContent.trim() === "FAQ Topics",
            );
          if (faqTopicsBtn) left.insertBefore(btn, faqTopicsBtn);

          const panel = document.createElement("div");
          panel.id = "favPanel";
          panel.style.cssText = [
            "display:none; position:absolute; z-index:9999;",
            "margin-top:8px; padding:12px;",
            "min-width:420px;", // comfortable minimum
            "max-width:90vw;", // never overflow viewport
            "width:auto;", // allow content-driven width
            "border:1px solid #e3e6ec; border-radius:12px; background:#fff;",
            "box-shadow:0 10px 24px rgba(0,0,0,0.10);",
          ].join("");
          btn.style.position = "relative";
          btn.parentElement.style.position = "relative";
          btn.parentElement.appendChild(panel);

          // [SORT & REMOVE HELPERS][LOCAL]
          // Internal helpers used only within Favorites panel:
          //   - _favStateCode(v): derive an uppercase state code (e.g., "TN")
          //   - _favTypeRank(v):  rank type (topics, FAQ list, single FAQ, etc.)
          //   - _faqNumber(v):    extract question number (Q3, Q12, ...)
          //   - _compareFav(a,b): multi-step sort by state → type → FAQ number → label
          //   - sortFavoritesView(list): sort a *copy* of the list for display only
          //   - removeByViewId(id): remove an item by logical viewId(...) and save

          function _favStateCode(v) {
            // prefer explicit state; fallback to ID like "TN-Q3"
            var st = (v && (v.state || v.stateCode || "")) || "";
            if (!st && v && v.id && /^[A-Za-z]{2}-Q\d+/.test(String(v.id))) {
              st = String(v.id).slice(0, 2);
            }
            return String(st).toUpperCase();
          }

          // rank types: topics (1), faq-related lists (2), single faq (3), otherwise (9)

          function _favTypeRank(v) {
            var t = String(v?.type || v?.mode || "").toLowerCase();
            // Topic cards (your left-side topics “cards”)
            if (t === "topic" || t === "topics" || t === "topic-card") return 1;

            // FAQ-related “lists” (full list, topics grid, category-filtered)
            if (
              t === "faq-list" ||
              t === "faq-topics" ||
              t === "faq-category" ||
              t === "faq-categories"
            )
              return 2;

            // Single FAQ detail
            if (t === "faq") return 3;

            // Heuristic fallbacks
            var label = String(v?.label || "").toUpperCase();
            if (
              /^[A-Z]{2}-Q\d+/.test(label) ||
              /^[A-Z]{2}-Q\d+/.test(String(v?.id || ""))
            )
              return 3;

            return 9;
          }

          // Extract numeric Q for "TN-Q23" → 23; otherwise 9999
          function _faqNumber(v) {
            var id = String(v?.id || v?.label || "");
            var m = id.match(/-Q(\d+)/i);
            return m ? parseInt(m[1], 10) : 9999;
          }

          function _compareFav(a, b) {
            // 1) by state
            var sa = _favStateCode(a),
              sb = _favStateCode(b);
            if (sa < sb) return -1;
            if (sa > sb) return 1;

            // 2) by type rank
            var ra = _favTypeRank(a),
              rb = _favTypeRank(b);
            if (ra !== rb) return ra - rb;

            // 3) within same type:
            // - for single FAQs: by Q number
            if (ra === 3) {
              var qa = _faqNumber(a),
                qb = _faqNumber(b);
              if (qa !== qb) return qa - qb;
            }

            // - otherwise: by label (case-insensitive)
            var la = String(a?.label || "").toLowerCase();
            var lb = String(b?.label || "").toLowerCase();
            if (la < lb) return -1;
            if (la > lb) return 1;
            return 0;
          }

          // sort a COPY (keeps saved order intact)
          function sortFavoritesView(list) {
            return (list || []).slice().sort(_compareFav);
          }

          // Remove by logical view id (so we can render a sorted list safely)
          function removeByViewId(id) {
            var list = load().filter(function (x) {
              return viewId(x) !== id;
            });
            save(list);
          }

          // [UI RENDER][LOCAL]
          // renderPanel():
          //   Rebuilds the Favorites dropdown panel:
          //     - Loads favorites and sorts them for display.
          //     - Widens the panel for readability.
          //     - For each favorite:
          //         * Renders label + state badge.
          //         * Provides a trash button to remove that favorite.
          //     - Wires "Add current" and "Clear all" buttons.
          function renderPanel() {
            const list = load();
            const sorted = sortFavoritesView(list); // display-only sort
            // BEGIN widen Favorites panel
            panel.style.width = "440px";
            panel.style.minWidth = "440px";
            panel.style.flex = "0 0 440px";
            // END widen Favorites panel

            panel.innerHTML = `
        <div style="display:flex;justify-content:space-between;align-items:center;gap:8px;margin-bottom:8px;">
          <strong>Favorites</strong>
          <div>
            <button id="favAddBtn" title="Add current view">Add current</button>
            <button id="favClearBtn" title="Clear all" style="margin-left:6px;">Clear all</button>
          </div>
        </div>
          <div class="fav-rule"></div>
        <div id="favList" style="max-height:520px;overflow:auto;"></div>
      `;
            const listEl = panel.querySelector("#favList");

            if (!sorted.length) {
              listEl.innerHTML = `<div style="color:#666;">No favorites saved.</div>`;
            } else {
              sorted.forEach((v) => {
                const row = document.createElement("div");
                row.style.cssText =
                  "display:flex;align-items:center;justify-content:space-between;gap:8px;padding:6px 0;border-bottom:1px dashed #f0f2f7;";

                const leftCol = document.createElement("div");
                leftCol.style.cssText = "flex:1;cursor:pointer;";

                const stateBadge = `<span style="display:inline-block;font-size:11px;border:1px solid #e3e6ec;border-radius:6px;padding:1px 6px;margin-left:6px;">${v.state}</span>`;
                leftCol.innerHTML = `${escapeHtml(v.label || v.mode)} ${stateBadge}`;
                leftCol.onclick = () => {
                  open(v);
                  hide();
                };

                const rm = document.createElement("button");
                rm.title = "Remove";
                rm.textContent = "🗑";
                rm.style.cssText =
                  "min-width:24px;padding:2px 6px;font-size:12px;line-height:1;";
                const vid = viewId(v); // logical id
                rm.onclick = () => {
                  removeByViewId(vid);
                  renderPanel();
                };

                row.appendChild(leftCol);
                row.appendChild(rm);
                listEl.appendChild(row);
              });
            }

            panel.querySelector("#favAddBtn").onclick = () => {
              addCurrent();
              renderPanel();
            };
            panel.querySelector("#favClearBtn").onclick = () => {
              clearAll();
              renderPanel();
            };
          }

          // [VISIBILITY][LOCAL]
          // show()/hide()/toggle():
          //   Simple visibility controls for the Favorites panel.
          //   - toggle(): switches between visible/hidden states.
         function show() {
            renderPanel();
            panel.style.display = "block";
          }
          function hide() {
            panel.style.display = "none";
          }
          function toggle() {
            panel.style.display === "block" ? hide() : show();
          }

          // [EVENTS][LOCAL]
          // Close panel when clicking outside; toggle when clicking the Favorites button.
          document.addEventListener("click", (e) => {
            if (!panel.contains(e.target) && e.target !== btn) hide();
          });
          btn.addEventListener("click", (e) => {
            e.stopPropagation();
            toggle();
          });
        }

        // [GLOBAL API]
        // Exposed surface under WE.Favorites:
        //   - addCurrent()
        //   - clearAll()
        //   - open()
        //   - ensureUI()
        return { addCurrent, clearAll, open, ensureUI };
      })();

      // [INIT][GLOBAL]
      // After the DOM and actions bar exist, call WE.Favorites.ensureUI()
      // to insert the Favorites button + panel into the UI.
      document.addEventListener("DOMContentLoaded", () => {
        setTimeout(() => {
          WE.Favorites.ensureUI && WE.Favorites.ensureUI();
        }, 0);
      });

      // [MODULE END] Favorites (WE.Favorites)
    </script>
    <!-- ===================================================================== -->
    <!-- 4) VERSION BANNER + FOOTER UTILITIES                                  -->
    <!-- ===================================================================== -->
    <script>
// [GLOBAL][UTILITY]
// excelSerialToDate(serial):
//   - Converts an Excel serial date number into a JS Date.
//   - Used by:
//       * Version/footer rendering
//       * Excel workbook export when writing _Meta fields.
      function excelSerialToDate(serial) {
        const s = Number(serial);
        if (!isFinite(s)) return null;
        const wholeDays = Math.floor(s);
        const frac = s - wholeDays;
        const adjust = wholeDays >= 60 ? 1 : 0; // Excel bug day 60
        const baseMs = Date.UTC(1899, 11, 31);
        const ms =
          baseMs +
          (wholeDays - adjust) * 86400000 +
          Math.round(frac * 86400000);
        return new Date(ms);
      }
      function parseMetaDate(val) {
        if (val == null) return null;
        if (val instanceof Date) return val;
        const str = String(val).trim();
        if (/^\d+(\.\d+)?$/.test(str)) {
          const d = excelSerialToDate(+str);
          return d && !isNaN(d) ? d : null;
        }
        const d2 = new Date(str);
        return isNaN(d2) ? null : d2;
      }
      function formatUIDateUTC(d) {
        return new Intl.DateTimeFormat("en-US", {
          month: "long",
          day: "numeric",
          year: "numeric",
          timeZone: "UTC",
        }).format(d);
      }
      function fmtSmart(v) {
        return v == null ? "" : String(v);
      }

// [GLOBAL][UI VERSION]
// showVersion():
//   - Injects the version banner into #versionDiv.
//   - Uses metadata from WE_CTX._Meta (if provided by loader).
      function showVersion() {
        try {
          var meta = (window.WE && WE.META) || window.WE_META;
          if (!meta) {
            var raw = sessionStorage.getItem("we_ctx_json_v1");
            if (raw) {
              var snap = JSON.parse(raw || "{}");
              meta = snap.META || {};
              window.WE = window.WE || {};
              window.WE.META = meta;
              window.WE_META = meta;
            } else {
              meta = {};
            }
          }
          var el = document.getElementById("beta-num");
          if (!el) return;

          var v = (meta.Version ?? meta.version ?? "").toString().trim();
          if (/^\d+$/.test(v)) v += ".0";
          else if (/^\d+[,\.]\d+$/.test(v)) v = v.replace(",", ".");

          var getTrim = (v) => (v == null ? "" : String(v).trim());
          var rev = getTrim(meta.RevisionDate || meta.revisionDate);
          var rel = getTrim(meta.ReleaseDate || meta.releaseDate);

          var sourceLabel = "";
          var rawDate = "";
          if (rev) {
            sourceLabel = "Revised";
            rawDate = rev;
          } else if (rel) {
            sourceLabel = "Released";
            rawDate = rel;
          }

          var dt = parseMetaDate(rawDate);
          var dateStr = dt ? formatUIDateUTC(dt) : fmtSmart(rawDate);
          var suffix =
            sourceLabel && dateStr ? " — " + sourceLabel + " " + dateStr : "";
          var verPart = v ? " v" + v : "";
          el.textContent = verPart + suffix;
        } catch (e) {
          console.warn("showVersion error:", e);
        }
      }
      function formatMDYUTC(d) {
        if (!(d instanceof Date) || isNaN(d)) return "";
        const pad = (n) => (n < 10 ? "0" : "") + n;
        return `${pad(d.getUTCMonth() + 1)}/${pad(d.getUTCDate())}/${d.getUTCFullYear()}`;
      }
      document.addEventListener("DOMContentLoaded", showVersion);
    </script>

    <!-- Row lookup: labels + order (from _Rows.Order) -->
    <!-- ===================================================================== -->
    <!-- 5) ROW METADATA HELPERS (labels, ordering)                            -->
    <!-- ===================================================================== -->
    <script>
      (function () {
        if (!window.WE || !Array.isArray(window.WE.ROWS)) return;

        var ROW_LABEL = {};
        var ROW_ORDER = {};

        (window.WE.ROWS || []).forEach(function (r) {
          var id = String((r && r.id) || "");
          var label = String((r && r.label) || id);
          if (!id) return;
          ROW_LABEL[id] = label;
          var raw =
            r &&
            (r.Order ??
              r.order ??
              r["Order "] ??
              r._order ??
              r.seq ??
              r.sequence);
          var num = Number.isFinite(+raw) ? +raw : 999999;
          ROW_ORDER[id] = num;
        });

        window.rLabel = function (rowId) {
          rowId = String(rowId || "");
          return ROW_LABEL[rowId] || rowId;
        };
        window.rowOrderIndex = function (rowId) {
          rowId = String(rowId || "");
          return rowId in ROW_ORDER ? ROW_ORDER[rowId] : 999999;
        };
      })();
    </script>

    <!-- Global delimiter + value rendering helpers -->
    <!-- ===================================================================== -->
    <!-- 6) VALUE RENDERING HELPERS (pipe / double-pipe parsing)               -->
    <!-- ===================================================================== -->

    <script>
      (function () {
        function esc(s) {
          return String(s ?? "").replace(
            /[&<>"]/g,
            (m) =>
              ({ "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;" })[m],
          );
        }
        function normalizeRaw(rawValue) {
        // Treat Word paragraph marks as newlines, then map them to pipes
        let s = String(rawValue ?? "");

        // Normalize all line endings
        s = s.replace(/\r\n/g, "\n").replace(/\r/g, "\n");

        // Two consecutive paragraph marks (blank line) => extra block gap
        // Example: "text\n\ntext" -> "text||||text"
        s = s.replace(/\n\n+/g, "||||");

        // Single paragraph mark => one block break
        // Example: "text\ntext" -> "text||text"
        s = s.replace(/\n/g, "||");

        return s;
        }
       function unescapePipes(s) {
          return String(s ?? "")
            .replace(/\\\|\|/g, "⟦DPIPE⟧")
            .replace(/\\\|/g, "⟦PIPE⟧");
        }
        function reinsertPipes(s) {
          return String(s ?? "")
            .replace(/⟦DPIPE⟧/g, "||")
            .replace(/⟦PIPE⟧/g, "|");
        }
        function detectDelimiter(rawValue) {
          const s = unescapePipes(normalizeRaw(rawValue));
          if (s.includes("||")) return "DPIPE";
          if (s.includes("|")) return "PIPE";
          return "NONE";
        }
        function splitByDetected(rawValue) {
          const raw = unescapePipes(normalizeRaw(rawValue));
          if (raw.includes("||"))
            return raw
              .split("||")
              .map((x) => reinsertPipes(x.trim()))
              .filter(Boolean);
          if (raw.includes("|"))
            return raw
              .split("|")
              .map((x) => reinsertPipes(x.trim()))
              .filter(Boolean);
          return [reinsertPipes(String(rawValue ?? ""))];
        }
        function renderBlock(blockText) {
          // Put back any escaped pipes before we look for '|'
          const txt = reinsertPipes(String(blockText ?? ""));
          const t = txt.trim();

          // Empty block -> vertical gap
          if (!t) {
            // You can tweak this spacing value as desired
            return '<div style="height:0.75rem;"></div>';
          }

          // If there is a '|' inside this block, treat it as a list *for this block only*
          if (t.includes("|")) {
            const items = t
              .split("|")
              .map((x) => x.trim())
              .filter(Boolean);

            if (items.length === 0) {
              return '<div style="height:0.75rem;"></div>';
            }

            if (items.length === 1) {
              // Single item with a pipe -> just render it as a normal block
              return `<div>${esc(items[0])}</div>`;
            }

            // Multiple items -> bulleted list
            return `<div><ul>${items
              .map((x) => `<li>${esc(x)}</li>`)
              .join("")}</ul></div>`;
          }

          // No '|' in this block -> simple paragraph
          return `<div>${esc(t)}</div>`;
        }

        function renderValueGlobal(rawValue) {
          if (rawValue == null || String(rawValue).trim() === "") return "";

          // 1) Normalize Word line breaks -> pipes, then unescape any literal pipes
          const normalized = unescapePipes(normalizeRaw(rawValue));

          // 2) Split into blocks by '||'
          const blocks = normalized.split("||");

          // 3) Render each block independently
          return blocks.map(renderBlock).join("");
        }

        window.WEApp = window.WEApp || {};
        WEApp.unescapePipes = unescapePipes;
        WEApp.reinsertPipes = reinsertPipes;
        WEApp.detectDelimiter = detectDelimiter;
        WEApp.splitByDetected = splitByDetected;
        WEApp.renderValue = renderValueGlobal;
      })();
    </script>

     <!-- Admin Topic Editor Modal -->
    <div id="adminEditModal" hidden>
      <div class="admin-modal-backdrop"></div>
      <div class="admin-modal-panel">
        <h2 id="adminEditTitle">Edit Topic Text</h2>

        <div class="admin-modal-main">
          <div class="admin-modal-column">
            <div class="admin-modal-label">Edit text</div>
            <textarea id="adminEditText"></textarea>
          </div>
          <div class="admin-modal-column">
            <div class="admin-modal-label">Preview</div>
            <div id="adminEditPreview"></div>
          </div>
        </div>

        <div class="admin-modal-footer">
          <div class="admin-modal-mode">
            <span>Edit mode:</span>
            <label>
              <input
                type="radio"
                name="adminEditMode"
                id="adminModeClean"
                value="clean"
                checked
              />
              Clean
            </label>
            <label>
              <input
                type="radio"
                name="adminEditMode"
                id="adminModeRaw"
                value="raw"
              />
              Raw
            </label>
          </div>
          <div class="admin-modal-buttons">
            <button type="button" id="adminEditCancel">Cancel</button>
            <button type="button" id="adminEditSave">Save</button>
          </div>
        </div>
      </div>
    </div>
<!-- Admin FAQ Editor Modal -->
<div id="adminFaqModal" hidden>
  <div class="admin-modal-backdrop"></div>
  <div class="admin-modal-panel">
    <div class="admin-faq-main">
<!-- Header row: title + buttons -->
<div class="admin-modal-header">
  <h2 id="adminFaqHeading">Edit FAQ</h2>
  <div class="admin-modal-buttons">
    <button type="button" id="adminFaqCancelBtn">Cancel</button>
    <button type="button" id="adminFaqSaveBtn">Save</button>
  </div>
</div>
<div class="admin-modal-underline"></div>
<div class="admin-faq-assigned">
  <div class="admin-modal-label">FAQ Topic Category Assignments</div>
  <div id="adminFaqAssigned"></div>
</div>

      <!-- Main grid: fields -->
      <div class="admin-modal-main admin-faq-main">
        <!-- (keep your existing Question / Short Answer / Citation / Legal Authority / Categories markup here unchanged) -->
      </div>

     <div class="admin-modal-grid">
        <div class="admin-modal-col">
          <div class="admin-modal-label">Question</div>
          <textarea id="adminFaqQuestion" class="admin-textarea"></textarea>

          <div class="admin-modal-label">Short Answer</div>
          <textarea id="adminFaqShortAnswer" class="admin-textarea"></textarea>

          <div class="admin-modal-label">Citation</div>
          <input id="adminFaqCitation" class="admin-input" type="text" />
          
        </div>

        <div class="admin-modal-col">
          <div class="admin-modal-label">Legal Authority (formatted like topic text)</div>
          <textarea
            id="adminFaqLegalAuthority"
            class="admin-textarea"
          ></textarea>

          <div class="admin-faq-cats-header">
            <span>FAQ Topics: Available Categories</span>
            <span id="adminFaqCatCount" class="admin-faq-cat-count"></span>
          </div>
          <div id="adminFaqCategories"></div>
          <div id="adminFaqCatHint" class="admin-faq-cat-hint"></div>
        </div>
      </div>

    </div>
  </div>
</div>

<script>
/* ============================================================
   ADMIN FAQ EDITOR — OPEN / CLOSE / POPULATE
   ============================================================ */
  (function () {
    const modal = document.getElementById("adminFaqModal");
    if (!modal) return;

    const questionEl = document.getElementById("adminFaqQuestion");
    const shortEl = document.getElementById("adminFaqShortAnswer");
    const authEl = document.getElementById("adminFaqLegalAuthority");
    const citeEl = document.getElementById("adminFaqCitation");
    const catsEl = document.getElementById("adminFaqCategories");
    const metaEl = document.getElementById("adminFaqMeta");
    const cancelBtn = document.getElementById("adminFaqCancelBtn");
    const saveBtn = document.getElementById("adminFaqSaveBtn");
    const catCountEl = document.getElementById("adminFaqCatCount");
    const catHintEl = document.getElementById("adminFaqCatHint");

    const MAX_CATS = 3;
    const DEFAULT_HINT =
      "Assign up to three categories so this FAQ appears in the right topic groupings.";
  function renderAssignedCategories() {
    const host = document.getElementById("adminFaqAssigned");
    if (!host || !catsEl) return;

    host.innerHTML = "";

    const selectedChips = catsEl.querySelectorAll(".faq-cat-chip.selected");
    if (!selectedChips.length) {
      const span = document.createElement("span");
      span.className = "admin-faq-assigned-empty";
      span.textContent = "No categories assigned yet.";
      host.appendChild(span);
      return;
    }

    selectedChips.forEach((chip) => {
      const tag = document.createElement("span");
      tag.className = "faq-assigned-chip";
      tag.textContent = chip.textContent;
      host.appendChild(tag);
    });
  }


  let faqDirty = false;

  function setFaqDirty(flag) {
    faqDirty = !!flag;
    if (!saveBtn) return;
    saveBtn.disabled = !faqDirty;
  }

    let currentState = null;
    let currentFaq = null;

    function pipesToClean(text) {
      return String(text || "")
        .replace(/\r\n/g, "\n")
        .split(/\|/g)
        .join("\n");
    }

    function cleanToPipes(text) {
      return String(text || "")
        .replace(/\r\n/g, "\n")
        .split(/\n+/)
        .map((s) => s.trim())
        .filter(Boolean)
        .join(" | ");
    }

    function collectAllFaqCategories() {
      const result = new Set();
      const byState = (window.WE && WE.FAQS_BY_STATE) || {};
      Object.values(byState).forEach((faqs) => {
        (faqs || []).forEach((f) => {
          const cats =
            Array.isArray(f.categories) && f.categories.length
              ? f.categories
              : [f.Category1, f.Category2, f.Category3];
          cats.forEach((c) => {
            const s = String(c || "").trim();
            if (s) result.add(s);
          });
        });
      });
      return Array.from(result).sort((a, b) => a.localeCompare(b));
    }

    function updateCatCount() {
  if (!catsEl || !catCountEl || !catHintEl) return;

  const selected = catsEl.querySelectorAll(".faq-cat-chip.selected").length;
  catCountEl.textContent = `${selected}/${MAX_CATS} selected`;

  if (selected === MAX_CATS) {
    catHintEl.style.color = "#b3261e";
    catHintEl.textContent =
      "You have successfully assigned this FAQ to three categories. To reassign or delete an assignment, click a selected category, then you can choose another.";
  } else {
    catHintEl.style.color = "#666";
    catHintEl.textContent =
      "Assign up to three categories so this FAQ appears in the right topic groupings.";
  }
}

    function buildCategoryChips(selectedCategories) {
      const allCats = collectAllFaqCategories();
      const selectedSet = new Set(
        (selectedCategories || []).map((c) => String(c || "").trim()),
      );

      catsEl.innerHTML = "";
      allCats.forEach((label) => {
        const chip = document.createElement("button");
        chip.type = "button";
        chip.className = "faq-cat-chip";
        chip.textContent = label;
        if (selectedSet.has(label)) chip.classList.add("selected");
        catsEl.appendChild(chip);
      });
      updateCatCount();
      renderAssignedCategories();
    }

    // Chip click handler with max-3 rule
catsEl.addEventListener("click", (evt) => {
  const chip = evt.target.closest(".faq-cat-chip");
  if (!chip) return;

  // If already selected, deselect (always allowed)
  if (chip.classList.contains("selected")) {
    chip.classList.remove("selected");
    setFaqDirty(true);
    updateCatCount();
    renderAssignedCategories();
    return;
  }

  // Otherwise we are trying to select a new category
  const selected = catsEl.querySelectorAll(".faq-cat-chip.selected").length;
  if (selected >= MAX_CATS) {
    // Don't add a 4th; just refresh the warning
    updateCatCount();
    return;
  }

  chip.classList.add("selected");
  updateCatCount();
  renderAssignedCategories();
  setFaqDirty(true);
});


    function closeModal() {
      modal.hidden = true;
      currentFaq = null;
      currentState = null;
    }
window.closeAdminFaqModal = closeModal;

    cancelBtn.addEventListener("click", closeModal);

    saveBtn.addEventListener("click", () => {
      if (!currentFaq || !currentState) {
        closeModal();
        return;
      }

      currentFaq.question = questionEl.value.trim();
      currentFaq.answer = shortEl.value.trim();
      currentFaq.citation = citeEl.value.trim();
      currentFaq.authority = cleanToPipes(authEl.value);

      const selected = Array.from(
        catsEl.querySelectorAll(".faq-cat-chip.selected"),
      ).map((chip) => chip.textContent.trim());

      const cats = selected.slice(0, MAX_CATS);
      currentFaq.categories = cats;
      currentFaq.Category1 = cats[0] || "";
      currentFaq.Category2 = cats[1] || "";
      currentFaq.Category3 = cats[2] || "";

      // Mark admin as needing export
      window.WE = window.WE || {};
      WE.ADMIN_UPDATE_NEEDED = true;
if (typeof window.updateAdminExportButtonState === "function") {
  window.updateAdminExportButtonState();
}

      // Push changes back into the ctx payload used by Excel export
      try {
        const raw = sessionStorage.getItem("we_ctx_json_v1");
        if (raw) {
          const ctx = JSON.parse(raw);
          if (Array.isArray(ctx.FAQS)) {
            const id = String(currentFaq.id || "");
            const st = String(currentState || "").toUpperCase();
            const match = ctx.FAQS.find(
              (f) =>
                String(f.id || "") === id &&
                String(f.state || "").toUpperCase() === st,
            );
            if (match) Object.assign(match, currentFaq);
          }
          sessionStorage.setItem("we_ctx_json_v1", JSON.stringify(ctx));
        }
      } catch (e) {
        console.warn("Unable to persist FAQ edits to ctx:", e);
      }

      // Re-render the same FAQ on the card
      if (typeof window.showFaqItem === "function") {
        window.showFaqItem(currentState, currentFaq);
      }
      setFaqDirty(false);
      closeModal();
    });
// Make FAQ close function available globally (for exitAdminMode)
window.closeAdminFaqModal = closeModal;

    window.openAdminFaqModal = function (stateKey, faq) {
      if (!faq) return;

      currentState = String(stateKey || "").toUpperCase();
      currentFaq = faq;
  const hdr = document.getElementById("adminFaqHeading");
  if (hdr) {
    hdr.textContent = faq.id ? `Edit FAQ ${faq.id}` : "Edit FAQ";
  }

      questionEl.value = faq.question || "";
      shortEl.value = faq.answer || "";
      citeEl.value = faq.citation || "";
      authEl.value = pipesToClean(faq.authority || "");

      const cats =
        Array.isArray(faq.categories) && faq.categories.length
          ? faq.categories
          : [faq.Category1, faq.Category2, faq.Category3];

      buildCategoryChips(
        (cats || []).map((c) => String(c || "").trim()).filter(Boolean),
      );

      // metaEl.textContent = faq.id ? `FAQ: ${faq.id}` : ""; (formerly used)
    // Start in "no unsaved changes" state
    setFaqDirty(false);
  if (questionEl) {
    questionEl.addEventListener("input", () => setFaqDirty(true));
  }
  if (shortEl) {
    shortEl.addEventListener("input", () => setFaqDirty(true));
  }
  if (citeEl) {
    citeEl.addEventListener("input", () => setFaqDirty(true));
  }
  if (authEl) {
    authEl.addEventListener("input", () => setFaqDirty(true));
  }

      modal.hidden = false;
      questionEl.focus();
    };

    // Close FAQ modal on Escape (only when open)
    window.addEventListener("keydown", (evt) => {
      if (evt.key === "Escape" && !modal.hidden) {
        closeModal();
      }
    });
  })();
</script>


<!-- Hidden-iframe printing + footer -->
<script>
      function printHtmlViaIframe(html) {
        const iframe = document.createElement("iframe");
        iframe.style.position = "fixed";
        iframe.style.width = "0";
        iframe.style.height = "0";
        iframe.style.border = "0";
        document.body.appendChild(iframe);

        const doc = iframe.contentWindow.document;
        doc.open();
        doc.write(html);
        doc.close();

        const finish = () => {
          iframe.contentWindow.focus();
          iframe.contentWindow.print();
          setTimeout(() => iframe.remove(), 300);
        };
        setTimeout(finish, 80);
      }
// [GLOBAL][UI FOOTER]
// showFooter():
//   - Populates bottom-of-page footer text (legal notices, version).
//   - Called once during startup after DOM is ready.
      function showFooter() {
        try {
          var meta = (window.WE && WE.META) || window.WE_META || {};
          var el = document.getElementById("page-footer");
          if (!el) return;
          function get(v) {
            return (meta[v] ?? meta[v.toLowerCase()] ?? "").toString().trim();
          }
          var copyright = get("Copyright");
          var notes = get("Notes");
          var text = "";
          if (copyright) text += copyright;
          if (notes) text += (copyright ? "\u00A0\u00A0" : ".  ") + notes;
          el.textContent = text;
        } catch (e) {
          console.warn("showFooter error:", e);
        }
      }
      document.addEventListener("DOMContentLoaded", showFooter);
    </script>
    <!-- ===================================================================== -->
    <!-- 7) MISC UX HELPERS (loaded states, active topic badge)                -->
    <!-- ===================================================================== -->
    <script>
  // [MODULE START] WEUX – Badges & Minor UI Decorations
  // =========================================================
  // [MODULE][GLOBAL]
  // Purpose:
  //   - Provide small UX helpers that decorate the main UI:
  //       * "Loaded states" badge (shows which states have data).
  //       * "Active topic" badge (shows which topic is currently selected).
  //
  // Globals:
  //   - window.WEUX (namespace container)
  //   - WEUX.updateActiveTopicBadge(...)     → update topic badge near header
  //   - WEUX.showLoadedStatesBadge(...)      → optional badge summarizing
  //                                            how many states are loaded.
  //
  // Dependencies:
  //   - WE.STATE_NAMES or WE_DATA (to know which states are present).
  //   - DOM elements near the header/footer where badges are rendered.
  //   - CURRENT_MODE / active topic label (passed in by callers).
  //
  // Notes:
  //   - This module does NOT change core logic or data; it is purely
  //     presentational. The app works without it, but looks nicer with it.
  // =========================================================
      // --- UX: Loaded states badge + Active topic badge ---
      (function () {
        function showLoadedStates() {
          try {
            var tgt = document.getElementById("loaded-states");
            if (!tgt) return;
            var list =
              window.WE && Array.isArray(window.WE.STATES)
                ? window.WE.STATES
                : null;
            var codes = [];
            if (list && list.length) {
              codes = list
                .map(function (s) {
                  return String(s.code || s.abbr || s.id || "").toUpperCase();
                })
                .filter(Boolean);
            } else if (window.WE && window.WE.STATE_NAMES) {
              codes = Object.keys(window.WE.STATE_NAMES);
            }
            if (!codes.length) return;
            tgt.textContent = "Loaded: " + codes.join(", ");
          } catch (e) {
            /* noop */
          }
        }

        function currentTopicLabel() {
          try {
            var key =
              (window.WE && WE.CURRENT_TOPIC) ||
              document
                .querySelector("#topicBtns .topic-pill.active")
                ?.getAttribute("data-topic") ||
              "Topic1_Title";
            if (typeof window.topicLabel === "function") return topicLabel(key);
            return key;
          } catch (e) {
            return "";
          }
        }
        function updateActiveTopicBadge() {
          try {
            var el = document.getElementById("activeTopicBadge");
            if (!el) return;
            var mode = String(window.CURRENT_MODE || "topics");
            if (mode !== "topics") {
              el.style.display = "none";
              return;
            }
            var stateSel = document.getElementById("stateSel");
            var sname =
              (window.WE && WE.STATE_NAMES && WE.STATE_NAMES[stateSel.value]) ||
              stateSel.value ||
              "";
            var label = currentTopicLabel();
            el.textContent = "Topic: " + label;
            el.style.display = "";
          } catch (e) {
            /* noop */
          }
        }

  // Expose for other modules
  // Ensure global WEUX namespace exists.
  // - All UX helpers in this module attach to WEUX.
        window.WEUX = window.WEUX || {};

  // [GLOBAL][UI DECORATION]
  // WEUX.updateActiveTopicBadge(stateCode, topicLabel):
  //   - Updates the "Active topic" badge near the top of the UI.
  //   - Usually shows something like: "KY — Overview" or "TN — Warranty Basics".
  //   - Called by:
  //       * Core runtime after rendering a topic card.
  //       * Admin mode re-render logic, when topic changes while in admin.
  //   - Purely visual: does not change data, only DOM.
        window.WEUX.updateActiveTopicBadge = updateActiveTopicBadge;

  // [GLOBAL][UI DECORATION]
  // WEUX.showLoadedStatesBadge():
  //   - Compiles a quick summary of which states have data loaded.
  //   - Renders a small badge or text snippet (e.g., "States: KY, OH, WV").
  //   - Typically called once near startup, after WE.STATE_NAMES / WE_DATA
  //     are available.
        window.WEUX.showLoadedStates = showLoadedStates;

        // On load
        document.addEventListener("DOMContentLoaded", function () {
          showLoadedStates();
          // initial badge paint once the app marks CURRENT_MODE and renders
          setTimeout(updateActiveTopicBadge, 0);
        });
      })();

  // [MODULE END] WEUX – Badges & Minor UI Decorations
    </script>
    
<!-- =========================================================
     SCRIPT MODULE: Core App Runtime & Modes
     RESPONSIBILITIES:
       - Rebuilds context from sessionStorage ("we_ctx_json_v1")
       - Sets up WE / WEApp globals and constants
       - Builds state dropdown and topic pills
       - Manages CURRENT_MODE (Topics, FAQ List, FAQ Item, etc.)
       - Renders:
           * Topic cards (Row3a/Row3b, headers, labels/values)
           * FAQ List view
           * FAQ Topic (grouped) view
       - Wires actions bar (Copy, Print, Print All, FAQ Topics)
       - Implements printing helpers:
           * buildCardPrintHTML (card-only print)
           * WEApp.buildStatePrintHTML (Print All Topics)
           * printFaqs (Print All FAQs)
       - Performs initial bootstrapping:
           * Default state "KY"
           * Initial topic "Topic1_Title"
     TIES TO DOC:
       "Core namespace & utilities", "Data loading & reconstruction",
       "State & mode management", "Rendering primitives",
       "Initialization module", and most of "Topics" + "FAQs".
   ========================================================= -->

<script>
      // -------------------------------------------------------------------
      // Global topicLabel helper
      // -------------------------------------------------------------------
      // Scope: GLOBAL (window.topicLabel)
      // Purpose:
      //   - Provides a simple way to map a topic ID (e.g., "Topic1_Title")
      //     to a human-readable label using WE.TOPICS.
      //   - Used wherever we need to show a friendly topic label instead of
      //     the raw key.
      // Notes:
      //   - Defined only if window.topicLabel is not already present, so it
      //     is safe to include even if another script defines it earlier.
      // -------------------------------------------------------------------
      (function () {
        if (typeof window.topicLabel === "function") return;

        function buildMap(pairs) {
          try {
            if (Array.isArray(pairs)) return Object.fromEntries(pairs);
          } catch (_) {}
          return {};
        }
        const pairs =
          window.WE && Array.isArray(window.WE.TOPICS)
            ? window.WE.TOPICS
            : null;
        const MAP = buildMap(pairs);

        window.topicLabel = function topicLabel(tid) {
          const key = String(tid ?? "");
          return MAP[key] || key;
        };
      })();

      // ===================================================================
      // 7) CORE UI LOGIC (initWarrantyApp)
      // ===================================================================
      // Scope: MODULE (IIFE) + selected GLOBAL exports
      //
      // Responsibilities:
      //   - Wire the main "Topics / FAQs" experience:
      //       * State dropdown
      //       * Topic pills
      //       * Main topic card (#card) sections
      //   - Track the current mode (topics vs. FAQ views).
      //   - Provide the primary render function for topic cards.
      //   - Own the card-based print / copy handlers for topics + FAQs.
      //
      // Key globals exposed from this block:
      //   - window.CURRENT_MODE       : tracks "topics", "faq-list", "faq-item", etc.
      //   - window.copyCardToClipboard: rich HTML copy of the main card.
      //   - WEApp.render              : render a topic card for (state, topicKey).
      //   - WEApp.buildStatePrintHTML : full "Print All Topics" HTML generator.
      //   - WEApp.updateRightActionsForMode
      //                               : retarget Copy / Print buttons per mode.
      //
      // Data dependencies:
      //   - Requires WE.STATE_NAMES and WE.ROWS (from loader payload).
      //   - Uses WE_DATA / DATA as the per-row/topic data source.
      //
      // UI dependencies:
      //   - #stateSel, #topicBtns, #card and its child sections
      //   - Right action buttons: #copyBtn, #printBtn, #printAllBtn
      //   - FAQ entry points: #faqBtn, #faqTopicsBtn, #faqMount
      //
      // Boot sequence (high level):
      //   1) Resolve state + topic definitions (STATE_NAMES, TOPIC_DEFS).
      //   2) Capture DOM references.
      //   3) Wire FAQ button and FAQ Topics button.
      //   4) Build state dropdown and topic pills.
      //   5) Set the default mode to "topics" and render the initial topic.
      // ===================================================================
    
      (function initWarrantyApp() {
        /* ================== Constants & DOM ================== */
        const STATE_NAMES = (window.WE && window.WE.STATE_NAMES) || {
          KY: "Kentucky",
          OH: "Ohio",
          WV: "West Virginia",
          VA: "Virginia",
          SC: "South Carolina",
          GA: "Georgia",
          TN: "Tennessee",
        };


        // Local helper: normalize a state code (e.g., "ky") to its full
        // display name using WE.STATE_NAMES when available.
        // Scope: LOCAL to initWarrantyApp (not exported globally).
        function stateFullName(k) {
          const code = String(k || "")
            .trim()
            .toUpperCase();
          if (window.WE && window.WE.STATE_NAMES && window.WE.STATE_NAMES[code])
            return window.WE.STATE_NAMES[code];
          if (STATE_NAMES && STATE_NAMES[code]) return STATE_NAMES[code];
          return code;
        }
        function clearActiveTopicPills() {
          const pills = document.querySelectorAll(
            "#topicBtns .topic-pill.active",
          );
          pills.forEach((p) => p.classList.remove("active"));
        }

        // Topic definitions:
        //   - When loader has provided WE.TOPICS, we use that canonical list.
        //   - Otherwise we fall back to a fixed default ordering / labels.
        // Structure:
        //   TOPIC_DEFS = [ [topicKey, label], ... ]
        const TOPIC_DEFS = (window.WE && window.WE.TOPICS) || [
          ["Topic1_Title", "Overview"],
          ["Topic2_Title", "Process & Timelines"],
          ["Topic3_Title", "Labor Rate Setting"],
          ["Topic4_Title", "Labor Time Allowances"],
          ["Topic5_Title", "Parts Reimbursement"],
          ["Topic6_Title", "Recalls & Stop Sales"],
          ["Topic7_Title", "Administration"],
          ["Topic8_Title", "Audits & Appeals"],
          ["Topic9_Title", "Required Data"],
          ["Topic10_Title", "Other Issues"],
        ];

        // Main per-row/per-topic data set.
        // Scope: LOCAL constant referring to the payload built by loaderv1b.
        // Expected shape:
        //   - Array of objects with fields like:
        //       state, topic, rowId, rowLabel, value, excerpts[], etc.
        const DATA = window.WE_DATA || window.DATA || [];

        // Core DOM elements used by the main Topics / FAQ views.
        // NOTE:
        //   These are captured once at startup; if the markup changes,
        //   this is the primary place to update the element lookups.
        const stateSel = document.getElementById("stateSel");
        const topicBtns = document.getElementById("topicBtns");
        const cardBox = document.getElementById("card");
        const meta = document.getElementById("meta");
        const summary = document.getElementById("summary");
        const checklist = document.getElementById("checklist");
        const pushbacks = document.getElementById("pushbacks");
        const cites = document.getElementById("cites");
        const excerpts = document.getElementById("excerpts");
        const copyBtn = document.getElementById("copyBtn");
        const printBtn = document.getElementById("printBtn");
        const printAllBtn = document.getElementById("printAllBtn");
        const faqTopicsBtn = document.getElementById("faqTopicsBtn");

        // FAQ entry point (LEFT actions: "FAQs" button)
        // - Switches the layout into FAQ list mode for the current state.
        // - Hides the topic card sections and uses #faqMount as the content area.
        // Scope: LOCAL wiring; relies on global window.showFaqList().
        const faqBtn = document.getElementById("faqBtn");
        if (faqBtn) {
          faqBtn.onclick = () => {
            const s = (stateSel?.value || "KY").toUpperCase();

            window.clearActiveTopicPills && window.clearActiveTopicPills();

            window.CURRENT_MODE = "faq-list";

            // Hide topic sections; show FAQ mount
            document
              .querySelectorAll("#card > :not(#faqMount)")
              .forEach((el) => {
                if (el.id !== "faqMount") {
                  el.setAttribute("data-prev-display", el.style.display || "");
                  el.style.display = "none";
                }
              });
            const mount = document.getElementById("faqMount");
            if (mount) mount.style.display = "block";

            // Big button: FULL FAQ LIST for the state
            if (typeof window.showFaqList === "function") {
              window.showFaqList(s);
            } else {
              // Fallback minimal list if helper missing
              const items = (window.WE?.FAQS_BY_STATE?.[s] || [])
                .slice()
                .sort(
                  (a, b) =>
                    (a.sort || 0) - (b.sort || 0) ||
                    String(a.id || "").localeCompare(String(b.id || "")),
                );
              mount.innerHTML =
                `<h3 style="margin:0 0 8px 0">Frequently Asked Questions — ${s}</h3>` +
                (items.length
                  ? `<div class="faq-list">${items
                      .map(
                        (it) =>
                          `<div class="faq-item">${it.id ? `${it.id}. ` : ""}${it.question || "(untitled)"}</div>`,
                      )
                      .join("")}</div>`
                  : `<p>No FAQs available for this state.</p>`);
            }

            // Update persistent right-side actions for FAQ views
            if (window.WEApp?.updateRightActionsForMode) {
              WEApp.updateRightActionsForMode("faq-list");
            }
          };
        }

        // -------------------------------------------------------------------
        // Mode + state helpers
        // -------------------------------------------------------------------
        // window.CURRENT_MODE (GLOBAL):
        //   - Tracks the current high-level view:
        //       "topics"   : topic card view
        //       "faq-list" : FAQ list/grid in #faqMount
        //       "faq-item" : single FAQ detail view
        //
        // currentState() (LOCAL helper):
        //   - Reads the selected state from #stateSel and normalizes it to
        //     uppercase (e.g., "ky" -> "KY").
        //   - Used by printing, Favorites, FAQ views, etc., to locate the
        //     correct state-specific data.
        // -------------------------------------------------------------------
        window.CURRENT_MODE = "topics"; // topics | faq-list | faq-item
        function currentState() {
          return (
            document.getElementById("stateSel")?.value || "KY"
          ).toUpperCase();
        }

        // Global helper: rich “Copy Card” handler (exported as window.copyCardToClipboard).
        // Scope:
        //   - Defined inside initWarrantyApp but attached to window so that
        //     Favorites and other modules can invoke it.
        // Purpose:
        //   - Copies the current #card contents to the clipboard as HTML,
        //     with special handling for the Row3a/Row3b two-column layout
        //     so Word keeps them side-by-side.
        // When on a TOPIC card, we also convert the special Row3a/Row3b
        // two-column layout into a simple HTML table so Word keeps it
        // side‑by‑side. FAQ views are copied as-is.
        function copyCardToClipboard() {
          const card = document.getElementById("card");
          if (!card) return;

          // Clone current card content so we can safely manipulate it
          const wrapper = document.createElement("div");
          wrapper.innerHTML = card.innerHTML;

          // Only apply the Row3a/Row3b → table transform when we are on a TOPIC card.
          const mode = String(window.CURRENT_MODE || "topics");
          if (mode === "topics") {
            const row3 = wrapper.querySelector('.card-row[data-rowid="Row3a"]');
            if (row3) {
              const cols = row3.querySelectorAll(".col");
              if (cols.length === 2) {
                const leftLabelEl = cols[0].querySelector(".row-label");
                const rightLabelEl = cols[1].querySelector(".row-label");
                const leftValueEl = cols[0].querySelector(".row-value");
                const rightValueEl = cols[1].querySelector(".row-value");

                const table = document.createElement("table");
                table.setAttribute("cellpadding", "4");
                table.setAttribute("cellspacing", "0");
                table.style.width = "100%";
                table.style.borderCollapse = "collapse";

                const headRow = document.createElement("tr");
                const th1 = document.createElement("th");
                const th2 = document.createElement("th");
                th1.textContent = leftLabelEl ? leftLabelEl.textContent : "";
                th2.textContent = rightLabelEl ? rightLabelEl.textContent : "";
                [th1, th2].forEach((th) => {
                  th.style.textAlign = "left";
                  th.style.border = "1px solid #ccc";
                });
                headRow.appendChild(th1);
                headRow.appendChild(th2);

                const bodyRow = document.createElement("tr");
                const td1 = document.createElement("td");
                const td2 = document.createElement("td");
                td1.innerHTML = leftValueEl ? leftValueEl.innerHTML : "";
                td2.innerHTML = rightValueEl ? rightValueEl.innerHTML : "";
                [td1, td2].forEach((td) => {
                  td.style.verticalAlign = "top";
                  td.style.border = "1px solid #ccc";
                });
                bodyRow.appendChild(td1);
                bodyRow.appendChild(td2);

                table.appendChild(headRow);
                table.appendChild(bodyRow);

                // Replace the original flex layout for this row with the table
                row3.innerHTML = "";
                row3.appendChild(table);
              }
            }
          }

          const htmlToCopy = wrapper.innerHTML;

          // --- Fallback plain‑text copy, using the live card text ---
          function fallbackPlain() {
            const tmp = document.createElement("textarea");
            tmp.value = card.innerText.trim();
            tmp.style.position = "fixed";
            tmp.style.opacity = "0";
            document.body.appendChild(tmp);
            tmp.focus();
            tmp.select();
            try {
              document.execCommand("copy");
            } catch (e) {
              console.warn("Plain copy failed", e);
            }
            document.body.removeChild(tmp);
          }

          // --- Prefer rich HTML copy if supported ---
          if (navigator.clipboard && window.ClipboardItem) {
            const type = "text/html";
            const blob = new Blob([htmlToCopy], { type });
            const data = new ClipboardItem({ [type]: blob });
            navigator.clipboard.write([data]).catch((err) => {
              console.warn(
                "Rich HTML copy failed, falling back to plain text",
                err,
              );
              fallbackPlain();
            });
          } else if (navigator.clipboard && navigator.clipboard.writeText) {
            // If we can’t push HTML, at least push the text cleanly
            navigator.clipboard
              .writeText(card.innerText.trim())
              .catch((err) => {
                console.warn(
                  "writeText failed, falling back to execCommand",
                  err,
                );
                fallbackPlain();
              });
          } else {
            fallbackPlain();
          }
        }

        // Make sure it’s reachable globally (Favorites etc. may call it)
        window.copyCardToClipboard = copyCardToClipboard;

        // --- Right actions: retarget per mode (topics vs FAQs) ---
// [LOCAL][CORE UI]
// clearTopicHelpForMode(mode):
//   - Removes inline topic help text when switching modes.
//   - Called by updateRightActionsForMode.

function clearTopicHelpForMode(mode) {
  var help = document.getElementById("topicHelp");
  if (!help) return;
  // Only keep the help text when we are in Topics mode
  if (mode === "topics") return;
  help.textContent = "";
}

       // Local helper: build a standalone HTML document for the CURRENT card.
       // Scope: LOCAL to initWarrantyApp (not exported directly).
       //
       // Behavior:
       //   - Reads #card.innerHTML.
       //   - Wraps it in a minimal HTML shell (DOCTYPE, <head>, inline <style>).
       //   - Used by:
       //       * "Print / Save Topic" (Topics mode)
       //       * "Print / Save FAQ"   (FAQ views)
       //
       // Important:
       //   - This print pathway is intentionally separate from:
       //       * WEApp.buildStatePrintHTML (Print All Topics)
       //       * window.printFaqs           (Print All FAQs)
      function buildCardPrintHTML() {
        const card = document.getElementById("card");
        if (!card) return "";
        const cardHtml = card.innerHTML || "";
        const titleEl = document.querySelector("header h1");
        const docTitle =
          (titleEl && titleEl.textContent) ||
          document.title ||
          "Warranty Reimbursement";

        function escTitle(s) {
          return String(s || "").replace(/[&<>"]/g, function (m) {
            return ({ "&": "&amp;", "<": "&lt;", ">": "&gt;" })[m] || m;
          });
        }

        return (
          "<!doctype html><html><head><meta charset=\"utf-8\">" +
          "<title>" +
          escTitle(docTitle) +
          "</title>" +
          "<style>" +
          // Basic palette and typography for print
          ":root{--pill-bg:#edf7ee;--pill-text:#2d6a4f;--pill-bg-active:#2d6a4f;--pill-text-active:#ffffff;--pill-border:#b7e4c7;}" +
          "body{font-family:system-ui,Arial,sans-serif;color:#111;margin:24px;}" +
          "h1{margin:0 0 6px 0;font-size:1.4rem;}" +
          "h2{margin:14px 0 6px;font-size:1.15rem;color:var(--pill-text);}" +
          ".muted{color:#555;font-size:0.9rem;}" +
          "ul{margin:6px 0 10px 18px;}" +
          "li{margin:0 0 12px;}" +
          "</style></head><body>" +
          "<h1>" +
          escTitle(docTitle) +
          "</h1>" +
          "<div class=\"card\">" +
          cardHtml +
          "</div>" +
          "</body></html>"
        );
      }

       // Global: retarget the RIGHT-side actions (Copy / Print / Print All)
       //         based on the current high-level mode.
       // Scope:
       //   - LOCAL function, but attached as WEApp.updateRightActionsForMode
       //     so other modules (FAQ, Notes, Favorites) can request a refresh.
       //
       // Responsibilities:
       //   - Always wires Copy to copyCardToClipboard().
       //   - In "topics" mode:
       //       * "Print / Save Topic" → card-based topic print (buildCardPrintHTML).
       //       * "Print All"         → state-wide topics print (buildStatePrintHTML).
       //   - In FAQ modes ("faq-list", "faq-item"):
       //       * "Print / Save FAQ"  → card-based FAQ print (buildCardPrintHTML).
       //       * "Print All"        → delegated to window.printFaqs(state).
       //
       // NOTE:
       //   - This is the single place where button labels and tooltips for
       //     the right-side actions are defined.
        function updateRightActionsForMode(mode) {
         clearTopicHelpForMode(mode);
         function setTip(el, tip) {
            if (!el) return;
            el.setAttribute("data-tip", tip);
            el.setAttribute("aria-label", tip);
            el.removeAttribute("title");
          }
          const state = currentState();

          // “Copy Card” always uses the rich HTML helper above
          if (copyBtn) {
            copyBtn.onclick = () => copyCardToClipboard();
          }

          if (mode === "topics") {
            printBtn.textContent = "Print / Save Topic";
            setTip(printBtn, "Print or save this topic as PDF");
            printBtn.onclick = () => {
    const html = buildCardPrintHTML();
    if (html && typeof printHtmlViaIframe === "function") {
      printHtmlViaIframe(html);
    } else {
      // Fallback to old behavior if something unexpected happens
      window.print();
    }
  };


            printAllBtn.textContent = "Print All";
            setTip(printAllBtn, "Print all topics for this state");
            printAllBtn.onclick = () => {
              const s = currentState();
              const html = buildStatePrintHTML(s);
              printHtmlViaIframe(html);
            };
          } else {
            // faq-list or faq-item
            printBtn.textContent = "Print / Save FAQ";
            setTip(printBtn, "Print or save this FAQ view");
              printBtn.onclick = () => {
    const html = buildCardPrintHTML();
    if (html && typeof printHtmlViaIframe === "function") {
      printHtmlViaIframe(html);
    } else {
      // Fallback to old behavior if something unexpected happens
      window.print();
    }
  };


            printAllBtn.textContent = "Print All";
            setTip(printAllBtn, "Print all FAQs for this state");
            printAllBtn.onclick = () => printFaqs(state);
          }
        }
        WEApp.updateRightActionsForMode = updateRightActionsForMode;

       // Left action: "FAQ Topics" button
       // Scope: LOCAL helper; called once during initWarrantyApp.
       //
       // Behavior:
       //   - Clears any active topic pill.
       //   - Sets mode to "faq-topics".
       //   - Hides the topic card sections and shows #faqMount.
       //   - Invokes:
       //       window.showFaqTopics(state)  if available,
       //       otherwise window.showFaqList(state).
        function wireFaqTopicsButton() {
          if (!faqTopicsBtn) return;
          faqTopicsBtn.onclick = () => {
            const s = currentState();

            window.clearActiveTopicPills && window.clearActiveTopicPills();

            window.CURRENT_MODE = "faq-topics";
            if (window.WEUX && WEUX.updateActiveTopicBadge)
              WEUX.updateActiveTopicBadge();

            // Hide the topic card sections; show faq mount
            document
              .querySelectorAll("#card > :not(#faqMount)")
              .forEach((el) => {
                if (el.id !== "faqMount") {
                  el.setAttribute("data-prev-display", el.style.display || "");
                  el.style.display = "none";
                }
              });
            const mount = document.getElementById("faqMount");
            if (mount) mount.removeAttribute("data-faq-category");

            if (mount) {
              mount.style.display = "block";
              mount.innerHTML = "<h3>FAQ Topics</h3><p>Loading…</p>";
            }
            if (typeof window.showFaqTopics === "function") {
              window.showFaqTopics(s);
            } else if (typeof window.showFaqList === "function") {
              window.showFaqList(s);
            }
            updateRightActionsForMode("faq-list");
          };
        }
        wireFaqTopicsButton();

        // Build state dropdown
        Object.keys(STATE_NAMES).forEach((code) => {
          const opt = document.createElement("option");
          opt.value = code;
          opt.textContent = STATE_NAMES[code];
          stateSel.appendChild(opt);
        });

        // Build topic pills
const topicsContainer = document.getElementById("topicBtns");
topicsContainer.innerHTML = "";

TOPIC_DEFS.forEach(([key, label]) => {
  const b = document.createElement("button");
  b.type = "button";
  b.className = "topic-pill";
  b.textContent = label;
  b.dataset.topic = key;

  // Prefer ID-based tips, then fall back to label; final fallback: 3rd element in TOPIC_DEFS if present
  const tipById = (window.WE && WE.TOPIC_TIPS_BY_ID) || {};
  const tipByLabel = (window.WE && WE.TOPIC_TIPS) || {};
  let tip = tipById[key] ?? tipByLabel[label] ?? "";

  if (!tip && Array.isArray(window.WE?.TOPICS)) {
    const def = window.WE.TOPICS.find((t) => t && t[0] === key);
    if (def && def[2]) tip = String(def[2]);
  }

  // We no longer use hover tooltips on topic pills; keep tip for help panel and a11y only
  if (tip) {
    b.setAttribute("aria-label", `${label}: ${String(tip)}`);
    b.removeAttribute("title");
  }

  b.onclick = () => {
    const state = stateSel.value;

    // Exit FAQ mode layout
    const faqMount = document.getElementById("faqMount");
    if (faqMount && faqMount.style) {
      faqMount.style.display = "none";
    }
    document
      .querySelectorAll("#card > :not(#faqMount)")
      .forEach((el) => {
        if (el.id !== "faqMount") {
          el.style.display = "";
          el.removeAttribute("data-prev-display");
        }
      });

    window.CURRENT_MODE = "topics";
    updateRightActionsForMode("topics");
    window.clearFaqCategoryButtons && window.clearFaqCategoryButtons();

    // Render the topic card as before
    WEApp.render(state, key, b);
    window.WEUX &&
      WEUX.updateActiveTopicBadge &&
      WEUX.updateActiveTopicBadge();

    // Update the help line with this topic's explanation
    const help = document.getElementById("topicHelp");
    if (help) {
      help.textContent = tip || "";
    }
  };

  topicsContainer.appendChild(b);
});

        // Mark initial topic active
        (function markInitialTopic() {
          const initialKey = "Topic1_Title";
          const btn = topicsContainer.querySelector(
            '[data-topic="' + initialKey + '"]',
          );
          if (btn) btn.classList.add("active");
        })();

        // State change
        stateSel.onchange = () => {
          const st = String(stateSel.value || "").toUpperCase();

          // Clear any active topic pill; we will re-activate during render
          [...topicBtns.children].forEach((b) => b.classList.remove("active"));

          // Check if a category is stamped on the mount
          const mount = document.getElementById("faqMount");
          const cat = mount ? mount.getAttribute("data-faq-category") : null;

          switch (String(window.CURRENT_MODE || "topics")) {
            case "faq-list": {
              // Full FAQ list for the new state
              document.getElementById("faqMount")?.style &&
                (document.getElementById("faqMount").style.display = "block");
              if (typeof window.showFaqList === "function")
                window.showFaqList(st);
              WEApp.updateRightActionsForMode("faq-list");
              break;
            }
            case "faq-category": {
              // Same category in the new state (if possible)
              document.getElementById("faqMount")?.style &&
                (document.getElementById("faqMount").style.display = "block");
              if (cat && typeof window.showFaqsForTopic === "function") {
                window.showFaqsForTopic(st, cat);
              } else if (typeof window.showFaqList === "function") {
                window.showFaqList(st);
              }
              WEApp.updateRightActionsForMode("faq-list");
              break;
            }
            case "faq-topics": {
              // Categories grid
              document.getElementById("faqMount")?.style &&
                (document.getElementById("faqMount").style.display = "block");
              if (typeof window.showFaqTopics === "function") {
                window.showFaqTopics(st);
              } else if (typeof window.showFaqList === "function") {
                window.showFaqList(st);
              }
              WEApp.updateRightActionsForMode("topics");
              break;
            }
            case "faq-item": {
              // Try to reopen the same FAQ id for the new state; fallback to list
              const cur =
                window.WE && WE.CURRENT_FAQ_ITEM ? WE.CURRENT_FAQ_ITEM : null;
              const id =
                cur && cur.id
                  ? String(cur.id)
                  : mount && mount.getAttribute("data-faq-id");
              if (id && typeof window.getFaqsByState === "function") {
                const arr = window.getFaqsByState(st) || [];
                const norm = (s) =>
                  String(s || "")
                    .toUpperCase()
                    .replace(/[^A-Z0-9]/g, "");
                const found = arr.find((x) => norm(x.id) === norm(id));
                if (found && typeof window.showFaqItem === "function") {
                  window.showFaqItem(st, found);
                  WEApp.updateRightActionsForMode("faq-list");
                  break;
                }
              }
              if (typeof window.showFaqList === "function")
                window.showFaqList(st);
              WEApp.updateRightActionsForMode("faq-list");
              break;
            }
            default: {
              // Stay in topics and render the SAME topic key for the new state
              window.CURRENT_MODE = "topics";

              const st = String(stateSel.value || "").toUpperCase();

              // 1) Capture the topic key we were on BEFORE changing classes or clicking anything
              const prevKey =
                topicBtns
                  .querySelector(".topic-pill.active")
                  ?.getAttribute("data-topic") ||
                (window.WE && WE.CURRENT_TOPIC) ||
                "Topic1_Title";

              // 2) Persist the key immediately so other code reads the right one
              window.WE = window.WE || {};
              window.WE.CURRENT_TOPIC = prevKey;

              // 3) Render that SAME topic for the new state (no pill click; prevent any "first pill" defaults)
              if (typeof window.WEApp?.render === "function") {
                WEApp.render(st, prevKey, null);
              }

              // 4) Update the pill UI to reflect the same topic
              [...topicBtns.children].forEach((b) =>
                b.classList.remove("active"),
              );
              const targetBtn = topicBtns.querySelector(
                `.topic-pill[data-topic="${prevKey}"]`,
              );
              if (targetBtn) targetBtn.classList.add("active");

              // 5) Keep right actions in topics mode
              if (typeof WEApp.updateRightActionsForMode === "function") {
                WEApp.updateRightActionsForMode("topics");
              }
              if (window.WEUX && WEUX.updateActiveTopicBadge)
                WEUX.updateActiveTopicBadge();
              break;
            }
          }
        };

        function esc(s) {
          return String(s ?? "").replace(
            /[&<>"]/g,
            (m) =>
              ({ "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;" })[m],
          );
        }

        // Helpers for Rows
        function getRowDef(rowId) {
          try {
            var rows = window.WE && Array.isArray(WE.ROWS) ? WE.ROWS : [];
            return (
              rows.find((r) => String((r && r.id) || "") === String(rowId)) ||
              {}
            );
          } catch (e) {
            return {};
          }
        }
        function splitList(text, preferred) {
          if (text == null) return [];
          var s = String(text).trim();
          if (!s) return [];
          var d = preferred && String(preferred).trim();
          if (d)
            return s
              .split(d)
              .map((x) => x.trim())
              .filter(Boolean);
          if (s.includes("||"))
            return s
              .split("||")
              .map((x) => x.trim())
              .filter(Boolean);
          if (s.includes("|"))
            return s
              .split("|")
              .map((x) => x.trim())
              .filter(Boolean);
          if (s.includes(";"))
            return s
              .split(";")
              .map((x) => x.trim())
              .filter(Boolean);
          return s
            .split(/\r?\n/)
            .map((x) => x.trim())
            .filter(Boolean);
        }
        /**
         * Render the main topic card for a given state + topic.
         *
         * Uses WE.ROWS to:
         *   - Decide which rows belong in the unified body (renderInBody === yes)
         *   - Respect row ordering (including the special Row3a/Row3b two-column layout)
         *
         * This is the SINGLE source of truth for on-screen topic layout.
         */
        function render(state, topic, btn) {
          window.WE && (window.WE.CURRENT_FAQ_ITEM = null); // leaving FAQ-item view; clear tracked item

          // Set headers from _Rows (UI Label)
          var HEADER_ROW_IDS = new Set(["Row3a", "Row3b"]);
          (function setHeadersFromRows() {
            function setTxt(id, txt) {
              var el = document.getElementById(id);
              if (el) el.textContent = txt;
            }
            var rows = window.WE && Array.isArray(WE.ROWS) ? WE.ROWS : [];
            function findHeaderRowId(sectionKey, idFallback) {
              var marked = rows.find(function (r) {
                return (r && r.headerFor) === sectionKey;
              });
              if (marked && marked.id) return String(marked.id);
              return idFallback ? String(idFallback) : "";
            }
            var hdrSummaryId = findHeaderRowId("summary", "Row1");
            var hdrAdminId = findHeaderRowId("admin", "Row2");
            var hdrPushId = findHeaderRowId("push", "Row3a");
            var hdrCitesId = findHeaderRowId("citations", "Row4");
            var hdrBodyId = findHeaderRowId("body", "Row5");
            HEADER_ROW_IDS.add(hdrSummaryId);
            HEADER_ROW_IDS.add(hdrAdminId);
            HEADER_ROW_IDS.add(hdrCitesId);

            setTxt("hdr-summary", rLabel(hdrSummaryId));
            setTxt("hdr-admin", rLabel(hdrAdminId));
            setTxt("hdr-push", rLabel(hdrPushId));
            setTxt("hdr-cites", rLabel(hdrCitesId));
            setTxt("hdr-excerpts", rLabel(hdrBodyId));
          })();

          Array.from(topicBtns.children).forEach((b) =>
            b.classList.remove("active"),
          );
          if (btn) btn.classList.add("active");

          const entry = DATA.find(
            (d) => d.state === state && d.topic === topic,
          );
          cardBox.hidden = false;

          meta.textContent =
            (STATE_NAMES[state] || state) + " — " + topicLabel(topic);
meta.style.color = "var(--pill-text)";

          if (!entry) {
            summary.textContent = "No entry yet.";
            checklist.innerHTML =
              pushbacks.innerHTML =
              cites.innerHTML =
              excerpts.innerHTML =
                "";
            return;
          }

          // Unified body: clear/hide legacy containers and write one body
          summary.textContent = "";
          checklist.innerHTML = "";
          try {
            pushbacks.innerHTML = "";
          } catch (_) {}
          cites.innerHTML = "";
          [
            "hdr-summary",
            "hdr-admin",
            "hdr-push",
            "hdr-cites",
            "hdr-excerpts",
          ].forEach((id) => {
            const h = document.getElementById(id);
            if (h) h.style.display = "none";
          });
          [summary, checklist, pushbacks, cites].forEach((box) => {
            if (!box) return;
            const wrapper =
              box.closest?.(".section") || box.parentElement || box;
            wrapper.style.display = "none";
          });
          if (excerpts) {
            const wrap =
              excerpts.closest?.(".section") ||
              excerpts.parentElement ||
              excerpts;
            wrap.style.display = "";
            excerpts.style.display = "";
          }

          const valueById = Object.fromEntries(
            (entry.excerpts || []).map((x) => [String(x.id || ""), x.value]),
          );
          function labelFor(id) {
            try {
              return typeof rLabel === "function" ? rLabel(id) : id || "";
            } catch (e) {
              return id || "";
            }
          }
          function orderOf(row) {
            const n = Number(row?.order ?? row?.Order);
            return Number.isFinite(n) ? n : 999999;
          }
          function renderInBodyRow(row) {
            if (!row) return false;
            const key = Object.keys(row).find(
              (k) =>
                String(k).replace(/\s+/g, "").toLowerCase() === "renderinbody",
            );
            const v = key ? row[key] : row.renderInBody;
            const s = String(v ?? "")
              .trim()
              .toLowerCase();
            return (
              v === true ||
              v === 1 ||
              s === "yes" ||
              s === "y" ||
              s === "true" ||
              s === "1"
            );
          }

          const rowsArr = window.WE && Array.isArray(WE.ROWS) ? WE.ROWS : [];
          const rowById = Object.fromEntries(
            rowsArr.map((r) => [String(r.id || ""), r]),
          );
          const ord3a = orderOf(rowById["Row3a"] || {});
          const ord3b = Number.isFinite(ord3a)
            ? ord3a
            : orderOf(rowById["Row3b"] || {});
          const orderedIds = rowsArr
            .filter((r) => renderInBodyRow(r))
            .map((r) => ({
              id: String(r.id || ""),
              ord: r.id === "Row3b" ? ord3b : orderOf(r),
            }))
            .sort(
              (a, b) =>
                a.ord - b.ord || String(a.id).localeCompare(String(b.id)),
            )
            .map((x) => x.id)
            .filter((id) => id !== "Row3b");

          const parts = [];
          for (const id of orderedIds) {
            if (id === "Row3a") {
              const labA = labelFor("Row3a");
              const labB = labelFor("Row3b");
              const vA = valueById["Row3a"];
              const vB = valueById["Row3b"];
              const htmlA = WEApp.renderValue(vA);
              const htmlB = WEApp.renderValue(vB);

              const adminIconA =
                window.WE && WE.ADMIN_MODE
                  ? ` <span class="admin-edit-icon" data-rowid="Row3a" data-rowlabel="${esc(labA)}" title="Edit ${esc(labA)}">&#9998;</span>`
                  : "";
              const adminIconB =
                window.WE && WE.ADMIN_MODE
                  ? ` <span class="admin-edit-icon" data-rowid="Row3b" data-rowlabel="${esc(labB)}" title="Edit ${esc(labB)}">&#9998;</span>`
                  : "";

              parts.push(`
            <div class="card-row two-col" data-rowid="Row3a" data-order="${ord3a}" style="display:flex; gap:24px; align-items:flex-start;">
              <div class="col" style="flex:1 1 50%;">
                <h3 class="row-label">${esc(labA)}${adminIconA}</h3>
                <div class="row-value">${htmlA}</div>
              </div>
              <div class="col" style="flex:1 1 50%;">
                <h3 class="row-label">${esc(labB)}${adminIconB}</h3>
                <div class="row-value">${htmlB}</div>
              </div>
            </div>
          `);
              continue;
            }
            const row = rowById[id] || { id };
            const label = labelFor(id);
            const value = valueById[id];
            const html = WEApp.renderValue(value);

            const adminIcon =
              window.WE && WE.ADMIN_MODE
                ? ` <span class="admin-edit-icon" data-rowid="${id}" data-rowlabel="${esc(
                    label,
                  )}" title="Edit ${esc(label)}">&#9998;</span>`
                : "";

            parts.push(`
          <div class="card-row" data-rowid="${id}" data-order="${orderOf(row)}">
            <h3 class="row-label">${esc(label)}${adminIcon}</h3>
            <div class="row-value">${html}</div>
          </div>
        `);
          }
          excerpts.innerHTML = parts.join("");
        }

        // Export render in WEApp and stamp CURRENT_TOPIC before delegating
        const _origRender = render;
        WEApp.render = function (stateKey, topicKey, btn) {
          window.WE = window.WE || {};
          window.WE.CURRENT_TOPIC = String(topicKey || "Topic1_Title"); // <-- persist active topic key
          return _origRender(stateKey, topicKey, btn);
        };
        // ----- Admin topic editing (pencil icon + modal) -----
        (function setupAdminTopicEditor() {
          const card = cardBox;
          if (!card) return;

          // Ensure a default for the admin pipe mode
          window.WE = window.WE || {};
          if (!WE.ADMIN_PIPE_MODE) {
            WE.ADMIN_PIPE_MODE = "clean"; // "clean" or "raw"
          }

          let currentEdit = null;

          function getCurrentStateKey() {
            const sel = document.getElementById("stateSel");
            return String((sel && sel.value) || "KY").toUpperCase();
          }

          function getCurrentTopicKey() {
            if (window.WE && WE.CURRENT_TOPIC) return String(WE.CURRENT_TOPIC);
            return "Topic1_Title";
          }
          function getCurrentTopicLabel() {
            const key = getCurrentTopicKey();
            // Prefer TOPIC_DEFS if available
            if (Array.isArray(TOPIC_DEFS)) {
              const found = TOPIC_DEFS.find((t) => t[0] === key);
              if (found && found[1]) return String(found[1]);
            }
            // Fallback: use WE.TOPICS if it’s an array of { key, label }
            if (window.WE && Array.isArray(WE.TOPICS)) {
              const found = WE.TOPICS.find((t) => t.key === key);
              if (found && found.label) return String(found.label);
            }
            // Last resort: just return the key
            return key;
          }

          function pipesToClean(raw) {
            const s = String(raw ?? "");
            if (!s) return "";
            const blocks = s.split("||");
            const out = [];

            blocks.forEach((block, i) => {
              const trimmed = String(block ?? "").trim();
              if (!trimmed) {
                out.push("");
              } else if (trimmed.includes("|")) {
                const items = trimmed
                  .split("|")
                  .map((x) => x.trim())
                  .filter(Boolean);
                if (items.length) {
                  items.forEach((it) => out.push("- " + it));
                }
              } else {
                out.push(trimmed);
              }
              if (i < blocks.length - 1) {
                out.push("");
              }
            });

            while (out.length && !out[0].trim()) out.shift();
            while (out.length && !out[out.length - 1].trim()) out.pop();

            return out.join("\n");
          }

          function cleanToPipes(text) {
            if (text == null) return "";
            let s = String(text);
            s = s.replace(/\r\n/g, "\n").replace(/\r/g, "\n");
            const lines = s.split("\n");

            const blocks = [];
            let current = [];

            for (const line of lines) {
              const trimmed = line.trim();
              if (!trimmed) {
                if (current.length) {
                  blocks.push(current);
                  current = [];
                }
              } else {
                current.push(line);
              }
            }
            if (current.length) blocks.push(current);

            const blockStrings = blocks.map((blockLines) => {
              const trimmedLines = blockLines.map((l) => l.trim());
              const isBulletGroup = trimmedLines.length > 0 &&
                trimmedLines.every((l) => /^[-*•]\s+/.test(l));
              if (isBulletGroup) {
                const items = trimmedLines
                  .map((l) => l.replace(/^[-*•]\s+/, "").trim())
                  .filter(Boolean);
                return items.join("|");
              } else {
                const joined = trimmedLines.join(" ");
                return joined;
              }
            });

            return blockStrings.join("||");
          }
          // Expose cleaners on WE so other admin tools (like the FAQ editor)
          // can reuse the same formatting behavior as topics.
          window.WE = window.WE || {};
          WE.pipesToClean = pipesToClean;
          WE.cleanToPipes = cleanToPipes;

          function updatePreviewFromTextarea() {
            const modal = document.getElementById("adminEditModal");
            if (!modal || !currentEdit) return;
            const ta = document.getElementById("adminEditText");
            const prev = document.getElementById("adminEditPreview");
            if (!ta || !prev) return;

            let rawForPreview;
            if (WE.ADMIN_PIPE_MODE === "raw") {
              rawForPreview = ta.value;
            } else {
              rawForPreview = cleanToPipes(ta.value);
            }

            try {
              prev.innerHTML = window.WEApp.renderValue(rawForPreview);
            } catch (e) {
              prev.innerHTML = "<div>(preview unavailable)</div>";
              console.warn("Admin preview error", e);
            }
          }

          function openEditor(rowId, rowLabel, rowRef, rawValue) {
            const modal = document.getElementById("adminEditModal");
            const titleEl = document.getElementById("adminEditTitle");
            const ta = document.getElementById("adminEditText");
            const prev = document.getElementById("adminEditPreview");
            const modeClean = document.getElementById("adminModeClean");
            const modeRaw = document.getElementById("adminModeRaw");
            const btnCancel = document.getElementById("adminEditCancel");
            const btnSave = document.getElementById("adminEditSave");

            if (
              !modal ||
              !titleEl ||
              !ta ||
              !prev ||
              !modeClean ||
              !modeRaw ||
              !btnCancel ||
              !btnSave
            ) {
              console.warn("Admin edit modal elements missing");
              return;
            }

            currentEdit = {
              stateKey: getCurrentStateKey(),
              topicKey: getCurrentTopicKey(),
              rowId,
              rowLabel,
              rowRef,
              originalValue: rawValue,
            };

            const stateKey = getCurrentStateKey();
            const topicKey = getCurrentTopicKey();
            const topicLabel = getCurrentTopicLabel();

            titleEl.textContent =
              "Edit “" +
              String(rowLabel || rowId || "").trim() +
              "” — " +
              stateKey +
              " / " +
              topicLabel;

            if (WE.ADMIN_PIPE_MODE === "raw") {
              modeRaw.checked = true;
              modeClean.checked = false;
              ta.value = String(rawValue ?? "");
            } else {
              modeClean.checked = true;
              modeRaw.checked = false;
              ta.value = pipesToClean(rawValue);
            }

            updatePreviewFromTextarea();

            modal.hidden = false;

            ta.oninput = updatePreviewFromTextarea;
            modeClean.onchange = () => {
              if (!currentEdit) return;
              WE.ADMIN_PIPE_MODE = "clean";
              ta.value = pipesToClean(currentEdit.rowRef.value ?? "");
              updatePreviewFromTextarea();
            };
            modeRaw.onchange = () => {
              if (!currentEdit) return;
              WE.ADMIN_PIPE_MODE = "raw";
              ta.value = String(currentEdit.rowRef.value ?? "");
              updatePreviewFromTextarea();
            };

            btnCancel.onclick = () => {
              modal.hidden = true;
              currentEdit = null;
            };

            btnSave.onclick = () => {
              if (!currentEdit) return;
              let newRaw;
              if (WE.ADMIN_PIPE_MODE === "raw") {
                newRaw = ta.value;
              } else {
                newRaw = cleanToPipes(ta.value);
              }
              newRaw = String(newRaw ?? "");

              currentEdit.rowRef.value = newRaw;

              try {
                if (window.WE_CTX && Array.isArray(window.WE_CTX.ENTRIES)) {
                  const stateKey = currentEdit.stateKey;
                  const topicKey = currentEdit.topicKey;
                  const rowIdLocal = currentEdit.rowId;
                  const entryCtx = window.WE_CTX.ENTRIES.find(
                    (d) =>
                      String(d.state || "").toUpperCase() === stateKey &&
                      String(d.topic || "") === topicKey,
                  );
                  if (entryCtx && Array.isArray(entryCtx.excerpts)) {
                    const ex = entryCtx.excerpts.find(
                      (x) => String(x.id || "") === String(rowIdLocal),
                    );
                    if (ex) {
                      ex.value = newRaw;
                    }
                  }
                  sessionStorage.setItem(
                    "we_ctx_json_v1",
                    JSON.stringify(window.WE_CTX),
                  );
                }
              } catch (e) {
                console.warn("Admin edit save/sessionStorage error", e);
              }

              try {
                window.WEApp.render(
                  currentEdit.stateKey,
                  currentEdit.topicKey,
                  null,
                );
              } catch (e) {
                console.warn("Admin re-render error", e);
              }
              try {
                window.WE = window.WE || {};
                WE.ADMIN_UPDATE_NEEDED = true;
                if (typeof window.updateAdminExportButtonState === "function") {
                  window.updateAdminExportButtonState();
                }
              } catch (e) {
                console.warn("Admin dirty-flag update error", e);
              }

              modal.hidden = true;
              currentEdit = null;
            };
          }

card.addEventListener("click", function (evt) {
  const target = evt.target;
  if (!target) return;
  const icon = target.closest
    ? target.closest(".admin-edit-icon")
    : null;
  if (!icon) return;

  if (!window.WE || !WE.ADMIN_MODE) return;
  if (String(window.CURRENT_MODE || "topics") !== "topics") return;

  const rowId = icon.getAttribute("data-rowid") || "";
  const rowLabel = icon.getAttribute("data-rowlabel") || rowId;
  if (!rowId) return;

  const stateKey = getCurrentStateKey();
  const topicKey = getCurrentTopicKey();

  const entry = DATA.find(
    (d) =>
      String(d.state || "").toUpperCase() === stateKey &&
      String(d.topic || "") === topicKey,
  );
  if (!entry || !Array.isArray(entry.excerpts)) {
    console.warn("Admin edit: no entry/excerpts for", stateKey, topicKey);
    return;
  }

  let rowRef = entry.excerpts.find(
    (x) => String(x.id || "") === String(rowId),
  );

  if (!rowRef) {
    // Row exists in layout (from WE.ROWS) but has never had content.
    // Create a new excerpt so the editor can work with an empty value.
    const rowsArr =
      window.WE && Array.isArray(WE.ROWS) ? WE.ROWS : [];
    const metaRow =
      rowsArr.find(
        (r) => String(r.id || "") === String(rowId),
      ) || {};

    rowRef = {
      id: rowId,
      label: rowLabel,
      value: "",
      type: metaRow.type || metaRow.Type || "",
      order: Number(metaRow.order ?? metaRow.Order ?? 0) || 0,
      renderInBody: true,
    };

    entry.excerpts.push(rowRef);
  }

  const rawValue = rowRef.value ?? "";
  openEditor(rowId, rowLabel, rowRef, rawValue);
});

        })();

        // Right actions: simple print handler default; print-all overridden per mode
        printBtn.onclick = () => window.print();

       function buildStatePrintHTML(stateKey) {
          const state = String(stateKey || "").toUpperCase();
          const raw =
            (window.WE && WE.STATE_REVISION && WE.STATE_REVISION[state]) || "";
          let dateStr = "";
          if (raw) {
            const dt = parseMetaDate(raw);
            dateStr = dt
              ? formatMDYUTC(dt)
              : /^\d{1,2}\/\d{1,2}\/\d{4}$/.test(String(raw))
                ? String(raw)
                : "";
          }
          const revLine = dateStr
            ? `<div style="font-size:12px;color:#555;margin:4px 0 12px 0;">Last Legal Update: ${dateStr}</div>`
            : "";
          const stateName = STATE_NAMES[state] || state;

          const entriesByTopic = {};
          DATA.forEach((e) => {
            if (e.state === state) entriesByTopic[e.topic] = e;
          });

          // ----- Row helpers (mirror the on-screen card behavior) -----
          const rowsArr = window.WE && Array.isArray(WE.ROWS) ? WE.ROWS : [];
          const rowById = Object.fromEntries(
            rowsArr.map((r) => [String(r.id || ""), r]),
          );

          function orderOf(row) {
            const n = Number(row?.order ?? row?.Order);
            return Number.isFinite(n) ? n : 999999;
          }

          function renderInBodyRow(row) {
            if (!row) return false;
            const key = Object.keys(row).find(
              (k) =>
                String(k).replace(/\s+/g, "").toLowerCase() === "renderinbody",
            );
            const v = key ? row[key] : row.renderInBody;
            const s = String(v ?? "")
              .trim()
              .toLowerCase();
            return (
              v === true ||
              v === 1 ||
              s === "yes" ||
              s === "y" ||
              s === "true" ||
              s === "1"
            );
          }

          function labelFor(id) {
            try {
              return typeof rLabel === "function" ? rLabel(id) : id || "";
            } catch (e) {
              return id || "";
            }
          }

          // Keep Row3a / Row3b together with shared order, just like the card
          const ord3a = orderOf(rowById["Row3a"] || {});
          const ord3b = Number.isFinite(ord3a)
            ? ord3a
            : orderOf(rowById["Row3b"] || {});
          const orderedIds = rowsArr
            .filter((r) => renderInBodyRow(r))
            .map((r) => ({
              id: String(r.id || ""),
              ord: r.id === "Row3b" ? ord3b : orderOf(r),
            }))
            .sort(
              (a, b) =>
                a.ord - b.ord || String(a.id).localeCompare(String(b.id)),
            )
            .map((x) => x.id)
            .filter((id) => id !== "Row3b"); // handled with Row3a

          // ----- Build sections using unified row list -----
          const sections = TOPIC_DEFS.map(([key, label]) => {
            const entry = entriesByTopic[key];

            if (!entry) {
              // No entry for this topic at all
              return `
            <section class="topic">
              <h2>${escapeHtml(label)}</h2>
              <p>No entry yet.</p>
            </section>`;
            }

            // Map row id -> value for this topic
            const valueById = Object.fromEntries(
              (entry.excerpts || []).map((x) => [String(x.id || ""), x.value]),
            );

            const parts = [];

            for (const id of orderedIds) {
              if (id === "Row3a") {
                // Two-column Row3a / Row3b, as on the card
                const labA = labelFor("Row3a");
                const labB = labelFor("Row3b");
                const vA = valueById["Row3a"];
                const vB = valueById["Row3b"];
                const htmlA =
                  window.WEApp && WEApp.renderValue
                    ? WEApp.renderValue(vA)
                    : escapeHtml(String(vA ?? ""));
                const htmlB =
                  window.WEApp && WEApp.renderValue
                    ? WEApp.renderValue(vB)
                    : escapeHtml(String(vB ?? ""));

                parts.push(`
              <div class="card-row two-col" data-rowid="Row3a" style="display:flex; gap:24px; align-items:flex-start;">
                <div class="col" style="flex:1 1 50%;">
                  <h3 class="row-label">${escapeHtml(labA)}</h3>
                  <div class="row-value">${htmlA}</div>
                </div>
                <div class="col" style="flex:1 1 50%;">
                  <h3 class="row-label">${escapeHtml(labB)}</h3>
                  <div class="row-value">${htmlB}</div>
                </div>
              </div>
            `);
                continue;
              }

              const row = rowById[id] || { id };
              const labelTxt = labelFor(id);
              const value = valueById[id];
              const htmlValue =
                window.WEApp && WEApp.renderValue
                  ? WEApp.renderValue(value)
                  : escapeHtml(String(value ?? ""));

              // IMPORTANT: don’t skip empty values – we still show the heading
              parts.push(`
            <div class="card-row" data-rowid="${escapeHtml(id)}" data-order="${orderOf(row)}">
              <h3 class="row-label">${escapeHtml(labelTxt)}</h3>
              <div class="row-value">${htmlValue}</div>
            </div>
          `);
            }

            const bodyHtml =
              parts.join("") || "<p>No content for this topic.</p>";

            return `
          <section class="topic">
            <h2>${escapeHtml(label)}</h2>
            ${bodyHtml}
          </section>`;
          }).join("\n");

          function escapeHtml(s) {
            return String(s ?? "").replace(
              /[&<>"]/g,
              (m) =>
                ({ "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;" })[m],
            );
          }

          return `<!doctype html>
<html><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1">
<title>${escapeHtml(stateName)} — Warranty Rules</title>
<style>
  :root{ --brand-red:#bc3737; --ink:#111; }
  body{ font-family:system-ui,Arial,sans-serif; color:var(--ink); margin:24px; }
  header{ margin-bottom:12px; }
  header h1{ margin:0; font-size:1.3rem; line-height:1.2; }
  .underline{ height:3px; background:var(--brand-red); border-radius:2px; margin:6px 0 4px; }
  h2{ margin:18px 0 6px; font-size:1.2rem; }
  h3{ margin:10px 0 4px; font-size:1.05rem; }
  ul{ margin:6px 0 10px 18px }
  blockquote{ margin:6px 0 10px; padding-left:10px; border-left:3px solid #ddd; }
  @media print{ body{ margin:12mm } }
 @media print {
    /* Don’t split a topic across pages if the browser can help it */
    .topic {
      page-break-inside: avoid;
      break-inside: avoid;
    }

    /* Every topic after the first starts on a new page */
    .topic + .topic {
      page-break-before: always;
      break-before: page;
    }
  }
 

</style></head>
<body>
  <header>
    <h1>${escapeHtml(stateName)} — Warranty Reimbursement Rules</h1>
    <div class="underline"></div>
    ${revLine}
  </header>

  ${sections}
</body></html>`;
        }
        WEApp.buildStatePrintHTML = buildStatePrintHTML;

         // -------------------------------------------------------------------
         // Initial bootstrapping
         // -------------------------------------------------------------------
         // 1) Default state selection:
         //      - Start in Kentucky ("KY") unless the dropdown is changed.
         // 2) Default mode:
         //      - Topics mode (window.CURRENT_MODE = "topics").
         // 3) Initial content:
         //      - Prefer the "Topic1_Title" pill if present;
         //        otherwise fall back to the first available topic pill.
         //      - Render that topic immediately so the user sees a full card.
         // -------------------------------------------------------------------
        stateSel.value = "KY";
        window.CURRENT_MODE = "topics";
        updateRightActionsForMode("topics");
        const firstBtn =
          topicsContainer.querySelector('[data-topic="Topic1_Title"]') ||
          topicsContainer.querySelector(".topic-pill");
        const firstKey = firstBtn?.getAttribute("data-topic") || "Topic1_Title";
        WEApp.render("KY", firstKey, firstBtn);
        if (window.WEUX && WEUX.updateActiveTopicBadge)
          WEUX.updateActiveTopicBadge();
      })();
    </script>
    <script>

      // Global helper: clearActiveTopicPills()
      // - Removes the "active" highlight class from all topic pills.
      // - Used by FAQ modules, Favorites, and other views when they pivot
      //   away from a topic card.
      window.clearActiveTopicPills = function () {
        try {
          document
            .querySelectorAll("#topicBtns .topic-pill.active")
            .forEach((p) => p.classList.remove("active"));
        } catch (_) {}
      };
    </script>
    <script>

      // [LOCAL][UI BUILDER]
      // addFaqCategoryButtons(stateCode, categories):
      //   - Builds clickable category buttons (e.g., tags) in the actions bar.
      //   - Clicking a category typically re-filters the FAQ list for that
      //     category only.
      // Up to 3 category buttons will be rendered.
      window.renderFaqCategoryButtons = function (stateKey, item) {
        const left = document.querySelector(".actions-left");
        if (!left || !item) return;

        // Remove old category buttons first
        left
          .querySelectorAll("button[data-faq-cat]")
          .forEach((b) => b.remove());

        // Collect categories: prefer item.categories[]; else Category1..3
        const rawCats =
          Array.isArray(item.categories) && item.categories.length
            ? item.categories
            : [item.Category1, item.Category2, item.Category3];

        const cats = [
          ...new Set(
            rawCats.map((c) => String(c || "").trim()).filter(Boolean),
          ),
        ].slice(0, 3);
        if (!cats.length) return;

        cats.forEach((cat) => {
          const btn = document.createElement("button");
          btn.type = "button";
          btn.setAttribute("data-faq-cat", cat);
          btn.textContent = cat;
          btn.title = `Show FAQs in ${cat}`;

          btn.onclick = () => {
            // Deselect any topic pill when pivoting to FAQ list
            window.clearActiveTopicPills && window.clearActiveTopicPills();

            const s = String(
              stateKey || document.getElementById("stateSel")?.value || "KY",
            ).toUpperCase();
            window.CURRENT_MODE = "faq-list";
            if (window.WEUX && WEUX.updateActiveTopicBadge)
              WEUX.updateActiveTopicBadge();

            // Show the FAQ mount, hide the topic sections
            document
              .querySelectorAll("#card > :not(#faqMount)")
              .forEach((el) => {
                if (el.id !== "faqMount") el.style.display = "none";
              });
            const m = document.getElementById("faqMount");
            if (m) m.style.display = "block";

            if (typeof window.showFaqsForTopic === "function") {
              window.showFaqsForTopic(s, cat);
            } else if (typeof window.showFaqList === "function") {
              window.showFaqList(s); // safe fallback
            }

            // Ensure right actions reflect FAQ mode
            window.WEApp?.updateRightActionsForMode?.("faq-list");
          };

          // Append after the persistent "FAQ Topics" button (leftmost)
          left.appendChild(btn);
        });
      };

      // [LOCAL][UI CLEANUP]
      // clearFaqCategoryButtons():
      //   - Removes any existing FAQ category buttons from the actions bar.
      //   - Called before adding a fresh set for a new view/state.
      window.clearFaqCategoryButtons = function () {
        const left = document.querySelector(".actions-left");
        if (!left) return;
        left
          .querySelectorAll("button[data-faq-cat]")
          .forEach((b) => b.remove());
      };
    </script>
    <!-- ===================================================================== -->
    <!-- 9) FAQ MODULES                                                        -->
    <!--     - getFaqsByState()                                               -->
    <!--     - showFaqItem(), showFaqList(), showFaqTopics(), showFaqsForTopic-->
    <!--     - renderFaqCategoryButtons(), clearFaqCategoryButtons()          -->
    <!--     - printFaqs()                                                    -->
    <!-- ===================================================================== -->
    <script>
      // [MODULE START] FAQ Views & Printing
      // =========================================================
      // [MODULE][GLOBAL ENTRY POINTS]
      // This module is responsible for all FAQ-based views and for
      // the "Print All FAQs" pathway. It REUSES the same WE data
      // structures built by the loader and by the core runtime.
      //
      // GLOBALS PROVIDED:
      //   - window.getFaqsByState(stateCode)
      //       → returns an array of FAQ objects for a given state key.
      //
      //   - window.showFaqList(stateCode)
      //       → renders FAQ list view for a state into #faqMount.
      //
      //   - window.showFaqItem(stateCode, faqId)
      //       → renders a single FAQ (question/answer) into #card or #faqMount
      //         depending on layout, and updates CURRENT_MODE.
      //
      //   - window.showFaqTopics(stateCode)
      //       → renders grouped FAQ view (by FAQ topic headings) into #faqMount.
      //
      //   - window.showFaqsForTopic(stateCode, topicKey)
      //       → helper for Favorites / FAQ Topics → FAQ List pivot.
      //
      //   - window.printFaqs(stateCode, options?)
      //       → builds its own standalone HTML and sends to printHtmlViaIframe.
      //
      // INTERNALS (LOCAL):
      //   - Helpers to group FAQs by topic, to format heading labels, and
      //     to assemble DOM nodes for FAQ list / topic views.
      //   - Category button helpers that live in the actions bar area
      //     (clearFaqCategoryButtons, addFaqCategoryButtons) if defined here.
      //
      // DATA DEPENDENCIES:
      //   - WE.FAQS_BY_STATE: main FAQ dataset grouped by state.
      //   - WE.TOPICS       : topic metadata, used for FAQ topic headings.
      //
      // UI DEPENDENCIES:
      //   - #stateSel       : current state selector
      //   - #card           : main card area (for single FAQ view, if used)
      //   - #faqMount       : container for FAQ list / topics layouts
      //   - Right actions   : Print / Print All repurposed when FAQ modes active
      // =========================================================


      // [GLOBAL][DATA ACCESS]
      // getFaqsByState(stateCode):
      //   - Returns the array of FAQs for the given state.
      //   - Uses WE.FAQS_BY_STATE, accepting either:
      //       * a 2-letter state code (e.g., "KY"), or
      //       * a state name where possible (if such mapping exists).
      //   - This is the primary way other modules fetch FAQ data per state.
      (function () {
        // Expose globally so Favorites and other modules can use it
        window.getFaqsByState = function (stateKey) {
          if (!window.WE || !window.WE.FAQS_BY_STATE) return [];
          return (
            window.WE.FAQS_BY_STATE[String(stateKey || "").toUpperCase()] || []
          );
        };

        // NOTE: we no longer replace the actions row in FAQ views.
        // We only switch modes and retarget right-side buttons.

      // [GLOBAL VIEW][SINGLE FAQ]
      // showFaqItem(stateCode, faqId):
      //   - Enters FAQ "Item" mode (CURRENT_MODE = "faq-item").
      //   - Renders a single FAQ (question + answer) for the given state
      //     and faqId.
      //   - Typically:
      //       * Clears any active topic pill (via window.clearActiveTopicPills()).
      //       * May reuse #card or #faqMount depending on layout design.
      //   - Used by:
      //       * FAQ list clicks
      //       * Favorites module for FAQ-type favorites
      //       * FAQ Topics → click → single FAQ pivot
        function showFaqItem(stateKey, item) {
          const mount = document.getElementById("faqMount");
          if (mount) mount.setAttribute("data-faq-id", String(item?.id || ""));
          window.clearActiveTopicPills && window.clearActiveTopicPills();

          if (!mount) return;

          window.CURRENT_MODE = "faq-item";
          // BEGIN remember currently open FAQ (safe, item-based)
          window.WE = window.WE || {};
          WE.CURRENT_FAQ_ID = String(item?.id || "");

          const _state =
            document.getElementById("stateSel")?.value ||
            String(stateKey || "");

          const _arr =
            typeof getFaqsByState === "function"
              ? getFaqsByState(_state) || []
              : [];

          const _found = _arr.find(
            (x) =>
              String(x.id || "").toUpperCase() ===
              String(item?.id || "").toUpperCase(),
          );

          WE.CURRENT_FAQ_QUESTION = _found
            ? _found.question || _found.q || ""
            : item?.question || "";
          // END remember currently open FAQ

          if (window.WEUX && WEUX.updateActiveTopicBadge)
            WEUX.updateActiveTopicBadge();
          WEApp.updateRightActionsForMode("faq-item");
          window.WE = window.WE || {};
          window.WE.CURRENT_FAQ_ITEM = item;

          // Ensure faq mount is visible; hide topic sections
          document.querySelectorAll("#card > :not(#faqMount)").forEach((el) => {
            if (el.id !== "faqMount") {
              el.setAttribute("data-prev-display", el.style.display || "");
              el.style.display = "none";
            }
          });
          mount.style.display = "block";

          // Body
          mount.innerHTML = "";

          // Breadcrumb
          const _code = String(stateKey || "").toUpperCase();
          const _stateName =
            (window.WE && WE.STATE_NAMES && WE.STATE_NAMES[_code]) || _code;

          const bc = document.createElement("div");
          bc.id = "faqBreadcrumb";
          bc.style.fontWeight = "600";
          bc.style.margin = "4px 0 12px";
          bc.style.color = "var(--pill-text)";
          bc.textContent = `FAQs for ${_stateName}`;
          mount.appendChild(bc);

          const t = document.createElement("div");
          t.className = "faq-title";

          // Base label: "ID. Question"
          const label =
            (item.id ? `${item.id}. ` : "") + (item.question || "(untitled)");
          t.textContent = label;

          // In Admin Mode, add a pencil icon to edit this FAQ
          if (window.WE && WE.ADMIN_MODE) {
            const icon = document.createElement("span");
            icon.className = "admin-edit-icon admin-faq-edit";
            icon.title = "Edit this FAQ";
            icon.innerHTML = "&#9998;"; // pencil glyph
            icon.style.marginLeft = "6px";
            icon.style.cursor = "pointer";

            icon.addEventListener("click", (evt) => {
              evt.stopPropagation();
              // Determine current state key from dropdown, falling back to stateKey
              const stateSel = document.getElementById("stateSel");
              const stKey = String(
                (stateSel && stateSel.value) || stateKey || ""
              ).toUpperCase();

              if (window.openAdminFaqModal) {
                window.openAdminFaqModal(stKey, item);
              }
            });

            t.appendChild(icon);
          }

          mount.appendChild(t);

          if (item.answer) {
            const s = document.createElement("p");
            s.style.fontWeight = "600";
            s.textContent = item.answer;
            mount.appendChild(s);
          }

          const cites = [item.authority, item.citation]
            .filter(Boolean)
            .join(" — ");
          if (cites) {
            const c = document.createElement("p");
            const strong = document.createElement("strong");
            strong.textContent = "Citation:";
            c.appendChild(strong);
            c.append(" " + String(cites));
            mount.appendChild(c);
          }
          // After mounting the Q&A content:
         window.renderFaqCategoryButtons &&
         window.renderFaqCategoryButtons(stateKey, item);
     }
     window.showFaqItem = showFaqItem;

     // Keyboard FAQ navigation: move to previous/next FAQ within current state
     window.navigateFaqRelative = function (delta) {
       try {
         // Only act when a single FAQ is open
         if (window.CURRENT_MODE !== "faq-item") return;

         // Determine current state
         const stateSel = document.getElementById("stateSel");
         const stateKey =
           (stateSel && stateSel.value) ||
           (window.WE &&
             (WE.CURRENT_STATE || WE.LAST_STATE || WE.DEFAULT_STATE)) ||
           "";

         if (!stateKey || typeof window.getFaqsByState !== "function")
           return;

         const list = window.getFaqsByState(stateKey) || [];
         if (!list.length) return;

         // Find current FAQ id
         const mount = document.getElementById("faqMount");
         const currentId =
           (window.WE && WE.CURRENT_FAQ_ID) ||
           (mount && mount.getAttribute("data-faq-id")) ||
           "";

         const normCurrent = String(currentId || "").toUpperCase();

         let idx = list.findIndex(
           (it) =>
             String(it.id || "").toUpperCase() === normCurrent,
         );

         // If we can't find current index:
         // - moving forward: treat as "before first" so +1 jumps to 0
         // - moving backward: treat as position 0 so -1 wraps to last
         if (idx < 0) {
           idx = delta > 0 ? -1 : 0;
         }

         // Wrap-around index
         const nextIndex =
           ((idx + delta) % list.length + list.length) % list.length;

         const nextItem = list[nextIndex];
         if (!nextItem) return;

         window.showFaqItem(stateKey, nextItem);
       } catch (e) {
         console.warn("navigateFaqRelative error", e);
       }
     };

      // [GLOBAL ACTION][PRINT ALL FAQS]
      // printFaqs(stateCode, opts?):
      //   - Builds a standalone HTML document containing:
      //       * All FAQs for the given state, OR
      //       * A filtered subset if opts/filtering are supplied.
      //   - Injects its own print-specific CSS (fonts, spacing, page breaks).
      //   - Sends the HTML to printHtmlViaIframe(html), separate from:
      //       * buildCardPrintHTML       (single card print)
      //       * WEApp.buildStatePrintHTML (all topics print)
      //   - This is the ONLY pathway used when "Print All" is invoked
      //     while in FAQ modes.
     function printFaqs(stateKey, overrideItems) {
       const esc = (s) =>
            String(s ?? "").replace(
              /[&<>"]/g,
              (m) =>
                ({ "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;" })[m],
            );

          const state = String(stateKey || "").toUpperCase();
          const stateName =
            (window.WE && WE.STATE_NAMES && WE.STATE_NAMES[state]) || state;
          const title = `FAQs — ${stateName}`;

          const base = Array.isArray(overrideItems)
            ? overrideItems
            : getFaqsByState(state);
          const items = base
            .slice()
            .sort(
              (a, b) =>
                (a.sort || 0) - (b.sort || 0) ||
                String(a.id || "").localeCompare(String(b.id || "")),
            );
          // Add a string to reflect last legal update
          // Use same logic/language as printAllTopics
          const rawDate = window.WE?.STATE_REVISION?.[state];
          let dateStr = "";

          if (rawDate) {
            const dt = parseMetaDate(rawDate); // handles Excel or string
            if (dt instanceof Date && !isNaN(dt)) {
              dateStr = formatUIDateUTC(dt); // e.g., "November 10, 2025"
            } else {
              dateStr = String(rawDate); // fallback if unparseable
            }
          }

          const revLine = dateStr
            ? `<div style="font-size:12px;color:#555;margin:4px 0 12px 0;">Last Legal Update: ${esc(dateStr)}</div>`
            : "";

          // Build the FAQ list HTML separately to avoid deep template nesting
          const faqHtml = items
            .map((it) => {
              const cites = [it.authority, it.citation]
                .filter(Boolean)
                .join(" — ");
              return `<div class="qa">
      <div class="q">${esc((it.id ? `${it.id}. ` : "") + (it.question || ""))}</div>
      ${it.answer ? `<div class="a">${esc(it.answer)}</div>` : ""}
      ${cites ? `<div class="c">${esc("Citation: " + cites)}</div>` : ""}
    </div>`;
            })
            .join("");

          const html = `<!doctype html><html><head><meta charset="utf-8"><title>${esc(title)}</title>
<style>
body{font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif;margin:24px}
h1{margin-top:0;font-size:1.5rem;line-height:1.15}
.qa{page-break-inside:avoid;margin:0 0 24px 0}
.q{font-weight:700;margin:0 0 6px 0}
.a{font-weight:600;margin:0 0 6px 0}
.c{font-style:italic;color:#333}
</style></head><body>
<h1>${esc(title)}</h1>
${revLine}
${faqHtml}
</body></html>`;

          if (typeof printHtmlViaIframe === "function") {
            printHtmlViaIframe(html);
          } else {
            // Fallback: open a new window to print
            const w = window.open("", "_blank");
            if (w) {
              w.document.write(html);
              w.document.close();
              w.focus();
              w.print();
              w.close();
            } else {
              window.print();
            }
          }
        }
        window.printFaqs = printFaqs;

        function uniqueCategories(stateKey) {
          const items = getFaqsByState(stateKey);
          const bag = new Set();
          items.forEach((f) => {
            const cats =
              Array.isArray(f.categories) && f.categories.length
                ? f.categories
                : [f.Category1, f.Category2, f.Category3];
            cats.forEach((c) => {
              const s = (c || "").toString().trim();
              if (s) bag.add(s);
            });
          });
          return Array.from(bag).sort((a, b) => a.localeCompare(b));
        }

      // [GLOBAL VIEW][FAQ TOPICS]
      // showFaqTopics(stateCode):
      //   - Enters FAQ "topics" mode (CURRENT_MODE = "faq-topics").
      //   - Renders FAQs grouped under topic headings:
      //       * Topic heading (drawn from WE.TOPICS or FAQ metadata)
      //       * List of questions under each heading
      //   - Clicking a question typically calls showFaqItem(...) to drill in.
      //   - Used by:
      //       * The "FAQ Topics" button in the left actions bar.
        window.showFaqTopics = function (stateKey) {
          window.clearActiveTopicPills && window.clearActiveTopicPills();
          window.clearFaqCategoryButtons && window.clearFaqCategoryButtons();

          window.CURRENT_MODE = "faq-topics";
          if (window.WEUX && WEUX.updateActiveTopicBadge)
            WEUX.updateActiveTopicBadge();

          WEApp.updateRightActionsForMode("topics");

          const mount = document.getElementById("faqMount");
          if (!mount) return;

          const state = String(stateKey || "").toUpperCase();
          const topics = uniqueCategories(state);

          // show mount; hide others
          document.querySelectorAll("#card > :not(#faqMount)").forEach((el) => {
            if (el.id !== "faqMount") {
              el.setAttribute("data-prev-display", el.style.display || "");
              el.style.display = "none";
            }
          });
          mount.style.display = "block";

          mount.innerHTML = '<h3 style="margin:0 0 8px 0">FAQ Topics</h3>';

          if (!topics.length) {
            mount.insertAdjacentHTML(
              "beforeend",
              "<p>No FAQ topics are available for this state.</p>",
            );
            return;
          }

          const grid = document.createElement("div");
          grid.className = "faq-topic-grid";

          topics.forEach((name) => {
            const item = document.createElement("div");
            item.className = "faq-topic-link";
            item.textContent = name;
            item.title = `View FAQs for “${name}”`;
            item.onclick = () => window.showFaqsForTopic(state, name);
            grid.appendChild(item);
          });

          mount.appendChild(grid);
        };

      // [GLOBAL VIEW][HELPER]
      // showFaqsForTopic(stateCode, topicKey):
      //   - Narrower view: list only FAQs for a specific topic within a state.
      //   - Often used when:
      //       * A Favorites entry refers to "FAQ for topic X".
      //       * A topic-based link wants to pivot into FAQ list mode.
      //   - Sets CURRENT_MODE appropriately and renders into #faqMount.
        window.showFaqsForTopic = function (stateKey, topicName) {
          window.CURRENT_MODE = "faq-list";
          if (window.WEUX && WEUX.updateActiveTopicBadge)
            WEUX.updateActiveTopicBadge();
          WEApp.updateRightActionsForMode("faq-list");

          const mount = document.getElementById("faqMount");
          if (!mount) return;

          const state = String(stateKey || "").toUpperCase();
          const tn = String(topicName || "").trim();
          // stamp the current category so Favorites can detect this view
          mount.setAttribute("data-faq-category", tn);

          const items = getFaqsByState(state)
            .filter((f) => {
              const cats =
                Array.isArray(f.categories) && f.categories.length
                  ? f.categories
                  : [f.Category1, f.Category2, f.Category3];
              return cats
                .map((x) => String(x || "").trim())
                .filter(Boolean)
                .includes(tn);
            })
            .sort(
              (a, b) =>
                (a.sort || 0) - (b.sort || 0) ||
                String(a.id || "").localeCompare(String(b.id || "")),
            );

          // show mount; hide others
          document.querySelectorAll("#card > :not(#faqMount)").forEach((el) => {
            if (el.id !== "faqMount") {
              el.setAttribute("data-prev-display", el.style.display || "");
              el.style.display = "none";
            }
          });
          mount.style.display = "block";

          // 1) Hard reset of the mount (always)
          if (mount.replaceChildren) {
            mount.replaceChildren();
          } else {
            while (mount.firstChild) mount.removeChild(mount.firstChild);
          }

          // 2) Derive a safe state display name
          const stateName =
            (window.WE && WE.STATE_NAMES && WE.STATE_NAMES[state]) || state;

          // 3) One (and only one) esc helper in this function
          const escLocal =
            typeof window.esc === "function"
              ? window.esc
              : (s) =>
                  String(s ?? "").replace(
                    /[&<>"]/g,
                    (m) =>
                      ({
                        "&": "&amp;",
                        "<": "&lt;",
                        ">": "&gt;",
                        '"': "&quot;",
                      })[m],
                  );

          // 4) Rebuild the Topic header we just cleared
          const header = document.createElement("div");
          header.className = "faq-topic-header";
          header.innerHTML = `
  <h3 style="margin:0 0 8px 0">
    FAQ Topic — ${escLocal(tn)}
    <span style="font-weight:500;color:#666"> · ${escLocal(stateName)}</span>
  </h3>
`;
          mount.appendChild(header);

          // [LOCAL][FAQ SEARCH UI]
          // Topic-scoped search + two-column preview:
          //   - Builds an inline search bar and FAQ list specifically for
          //     the current FAQ topic + state.
          //   - UI elements created here:
          //       * <input id="faqSearch">         → search within this topic’s FAQs
          //       * <span id="faqCount">          → "Showing N of M FAQs"
          //       * <button id="printFilteredBtn">→ "Print Filtered" (only when search active)
          //       * <div id="faqListContainer">   → holds the FAQ rows for this topic
          //   - All behavior (filtering, preview, printing) is wired locally in
          //     the following block: no globals are exported from this section.
          // 5) Build the topic-scoped search + two-column preview container
          const wrap = document.createElement("div");
          wrap.style.margin = "6px 0 12px";
          wrap.innerHTML = `
  <div style="display:flex;gap:8px;align-items:center;flex-wrap:wrap;">
    <input id="faqSearch" type="search" aria-label="Search FAQs in this topic"
           placeholder="Search this topic’s FAQs…"
           style="flex:1;min-width:260px;max-width:560px;padding:8px;border:1px solid #e3e6ec;border-radius:8px;">
    <span id="faqCount" style="font-size:12px;color:#666;"></span>
    <button id="printFilteredBtn" type="button"
            style="display:none;margin-left:auto;border:1px solid #e3e6ec;border-radius:8px;background:#fff;padding:6px 10px;cursor:pointer;"
            data-tip="Print filtered FAQs & answers">Print Filtered</button>
  </div>
  <div id="faqListContainer" class="faq-list" style="margin-top:8px;"></div>
`;
          mount.appendChild(wrap);
          // Local handles & data used for this topic’s FAQ search:
          //   - searchInput      : the search <input> for this topic.
          //   - countEl          : "Showing N of M FAQs" label.
          //   - listEl           : container for the FAQ rows (adds .faq-grid).
          //   - printFilteredBtn : optional button to print only the filtered
          //                         subset (shown when a search is active).
          //   - allFaqs          : unfiltered array of FAQs for this topic.
          //   - filtered         : current filtered subset shown in the list.

          // grab refs AFTER append
          const searchInput = wrap.querySelector("#faqSearch");
          const countEl = wrap.querySelector("#faqCount");
          const listEl = wrap.querySelector("#faqListContainer");
          listEl.classList.add("faq-grid");
          const printFilteredBtn = wrap.querySelector("#printFilteredBtn");

          // Topic-scoped source arrays
          const allFaqs = items.slice();
          let filtered = allFaqs.slice();

           // [LOCAL][PREVIEW]
          // buildPreview(answer, query):
          //   - Creates a short preview snippet of the answer text:
          //       * If no search query is active:
          //            → uses the first sentence or ~160 characters.
          //       * If a search query IS active:
          //            → tries to center the preview around the first match,
          //              with a bit of context on each side.
          //   - Used only for the hover/focus "answer preview" in the FAQ grid.
         function buildPreview(answer, query) {
            const text = String(answer || "").trim();
            if (!text) return "";
            const q = (query || "").trim();
            if (!q) {
              const dot = text.indexOf(".");
              const cut = dot >= 0 ? dot + 1 : Math.min(160, text.length);
              return text.slice(0, Math.max(80, Math.min(cut, 200))).trim();
            }
            const lower = text.toLowerCase();
            const qi = lower.indexOf(q.toLowerCase());
            if (qi < 0) return text.slice(0, 160).trim();
            const radius = 90;
            const start = Math.max(0, qi - radius);
            const end = Math.min(text.length, qi + q.length + radius);
            let s = text.slice(start, end).trim();
            if (start > 0) s = "… " + s;
            if (end < text.length) s = s + " …";
            return s;
          }

          // [LOCAL][PREVIEW]
          // clearAllPreviews():
          //   - Clears any existing preview text from all ".faq-a" cells
          //     in the current topic’s FAQ grid.
          //   - Called when the list is re-rendered or when we want to
          //     reset the hover/focus preview state.
         function clearAllPreviews() {
            listEl.querySelectorAll(".faq-a").forEach((el) => {
              el.textContent = "";
            });
          }

          // [LOCAL][UI RENDER]
          // renderList(arr):
          //   - Rebuilds the FAQ rows inside listEl for the given array:
          //       * Shows an empty state message when there are no matches.
          //       * For each FAQ:
          //           - .faq-q : question text (with optional ID prefix).
          //           - .faq-a : (initially empty) answer preview area.
          //   - Wires:
          //       * hover/focus events → showPreview()/hidePreview()
          //       * click              → showFaqItem(state, it)
          //   - Updates the count label (countEl) and "Print Filtered"
          //     visibility based on how many items are shown.
         function renderList(arr) {
            listEl.innerHTML = "";
            if (!arr.length) {
              const empty = document.createElement("div");
              empty.style.cssText = "padding:8px 0;color:#666;";
              empty.textContent = "No FAQs match your search.";
              listEl.appendChild(empty);
            } else {
              arr.forEach((it) => {
                const row = document.createElement("div");
                row.className = "faq-row";
                row.tabIndex = 0;

                const q = document.createElement("div");
                q.className = "faq-q";
                q.textContent =
                  (it.id ? `${it.id}. ` : "") + (it.question || "(untitled)");

                const a = document.createElement("div");
                a.className = "faq-a";
                a.textContent = "";

                const showPreview = () => {
                  clearAllPreviews();
                  a.textContent = buildPreview(
                    it.answer,
                    searchInput.value || "",
                  );
                };
                const hidePreview = (evt) => {
                  if (
                    evt &&
                    evt.type === "focusout" &&
                    row.contains(evt.relatedTarget)
                  )
                    return;
                  a.textContent = "";
                };

                row.addEventListener("mouseenter", showPreview);
                row.addEventListener("mouseleave", hidePreview);
                row.addEventListener("focusin", showPreview);
                row.addEventListener("focusout", hidePreview);

                row.onclick = () => showFaqItem(state, it);

                row.appendChild(q);
                row.appendChild(a);
                listEl.appendChild(row);
              });
            }

            const total = allFaqs.length;
            const shown = arr.length;
            countEl.textContent =
              shown === total
                ? `Showing ${total} FAQs`
                : `Showing ${shown} of ${total} FAQs`;

            const activeQuery = (searchInput.value || "").trim().length > 0;
            if (printFilteredBtn) {
              printFilteredBtn.style.display =
                activeQuery && shown > 0 ? "inline-block" : "none";
            }
          }

          clearAllPreviews();
          renderList(filtered);

          function applyFilter() {
            filtered = window.WE.searchItems(allFaqs, searchInput.value, [
              "question",
              "answer",
              "categories",
            ]);
            renderList(filtered);
            clearAllPreviews();
          }

          let debounceId;
          searchInput.addEventListener("input", () => {
            clearTimeout(debounceId);
            debounceId = setTimeout(applyFilter, 120);
          });

           // [EVENTS][LOCAL]
          // "Print Filtered" button:
          //   - Only visible when a search query is active and at least
          //     one FAQ matches.
          //   - On click, calls window.printFaqs(state, filtered) so that
          //     the printout includes only the currently filtered subset.
         if (printFilteredBtn) {
            printFilteredBtn.addEventListener("click", () => {
              if (typeof window.printFaqs === "function") {
                window.printFaqs(state, filtered);
              }
            });
          }
          // --- END: Topic-scoped FAQ search + two-column preview ---
        };

      // [GLOBAL VIEW][FAQ LIST]
      // showFaqList(stateCode):
      //   - Enters FAQ "List" mode (CURRENT_MODE = "faq-list").
      //   - Hides the topic card sections and shows #faqMount.
      //   - Renders a list/grid of all FAQs for the given state:
      //       * Question text
      //       * Short answer / excerpt
      //       * Category or topic tags (if available)
      //   - Wires each FAQ item so clicking it calls showFaqItem(...).
       window.showFaqList = function (stateKey) {
          window.clearActiveTopicPills && window.clearActiveTopicPills();
          window.clearFaqCategoryButtons && window.clearFaqCategoryButtons();
          window.WE && (window.WE.CURRENT_FAQ_ITEM = null);

          window.CURRENT_MODE = "faq-list";
          if (window.WEUX && WEUX.updateActiveTopicBadge)
            WEUX.updateActiveTopicBadge();
          WEApp.updateRightActionsForMode("faq-list");

          const mount = document.getElementById("faqMount");
          if (mount) mount.removeAttribute("data-faq-category");

          if (!mount) return;

          const state = String(stateKey || "").toUpperCase();
          const stateName =
            (window.WE && WE.STATE_NAMES && WE.STATE_NAMES[state]) ||
            document.querySelector(`#stateSel option[value="${state}"]`)
              ?.textContent ||
            state;

          document.querySelectorAll("#card > :not(#faqMount)").forEach((el) => {
            if (el.id !== "faqMount") {
              el.setAttribute("data-prev-display", el.style.display || "");
              el.style.display = "none";
            }
          });
          mount.style.display = "block";

          mount.innerHTML = `<h3 style="margin:0 0 8px 0">Frequently Asked Questions — ${stateName}</h3>`;

          const list = getFaqsByState(state)
            .slice()
            .sort(
              (a, b) =>
                (a.sort || 0) - (b.sort || 0) ||
                String(a.id || "").localeCompare(String(b.id || "")),
            );

          if (!list.length) {
            mount.insertAdjacentHTML(
              "beforeend",
              "<p>No FAQs available for this state.</p>",
            );
            return;
          }

          // --- BEGIN: FAQ search UI + live filter (confined to faq-list mode) ---
          // wrapper for search + count + list
          // [EVENTS][LOCAL]
          // Search input:
          //   - On each "input" event (user typing or clearing the box),
          //     re-compute `filtered`:
          //       * Empty query  → show allFaqs.
          //       * Non-empty    → keep only FAQs whose question/answer/
          //                       categories text contains the query.
          //   - Clears any existing previews and re-renders the grid.
         
          const wrap = document.createElement("div");
          wrap.style.margin = "6px 0 12px";
          wrap.innerHTML = `
  <div style="display:flex;gap:8px;align-items:center;flex-wrap:wrap;">
    <input id="faqSearch" type="search" aria-label="Search FAQs"
           placeholder="Search FAQs (question, answer, category)…"
           style="flex:1;min-width:260px;max-width:560px;padding:8px;border:1px solid #e3e6ec;border-radius:8px;">
    <span id="faqCount" style="font-size:12px;color:#666;"></span>
    <button id="printFilteredBtn" type="button"
            style="display:none;margin-left:auto;border:1px solid #e3e6ec;border-radius:8px;background:#fff;padding:6px 10px;cursor:pointer;"
            data-tip="Print filtered FAQs & answers">Print Filtered</button>
  </div>
  <div id="faqListContainer" class="faq-list" style="margin-top:8px;"></div>
`;

          mount.appendChild(wrap);

          // Grab handles
          const searchInput = wrap.querySelector("#faqSearch");
          const countEl = wrap.querySelector("#faqCount");
          const listEl = wrap.querySelector("#faqListContainer");
          listEl.classList.add("faq-grid");
          const printFilteredBtn = wrap.querySelector("#printFilteredBtn");

          // Source arrays
          const allFaqs = list; // original full list for this state
          let filtered = allFaqs.slice(); // currently visible list

          // Use your global esc if available; otherwise a safe local one:
          const escLocal =
            typeof esc === "function"
              ? esc
              : (s) =>
                  String(s ?? "").replace(
                    /[&<>"]/g,
                    (m) =>
                      ({
                        "&": "&amp;",
                        "<": "&lt;",
                        ">": "&gt;",
                        '"': "&quot;",
                      })[m],
                  );

          // Build a short preview from the answer; center around query when present.
          function buildPreview(answer, query) {
            const text = String(answer || "").trim();
            if (!text) return "";
            const q = (query || "").trim();
            if (!q) {
              const dot = text.indexOf(".");
              const cut = dot >= 0 ? dot + 1 : Math.min(160, text.length);
              return text.slice(0, Math.max(80, Math.min(cut, 200))).trim();
            }
            const lower = text.toLowerCase();
            const qi = lower.indexOf(q.toLowerCase());
            if (qi < 0) return text.slice(0, 160).trim();
            const radius = 90;
            const start = Math.max(0, qi - radius);
            const end = Math.min(text.length, qi + q.length + radius);
            let s = text.slice(start, end).trim();
            if (start > 0) s = "… " + s;
            if (end < text.length) s = s + " …";
            return s;
          }

          function clearAllPreviews() {
            listEl.querySelectorAll(".faq-a").forEach((el) => {
              el.textContent = "";
            });
          }

          // Render the visible list + toggle Print Filtered button
          function renderList(arr) {
            listEl.innerHTML = "";

            if (!arr.length) {
              const empty = document.createElement("div");
              empty.style.cssText = "padding:8px 0;color:#666;";
              empty.textContent = "No FAQs match your search.";
              listEl.appendChild(empty);
            } else {
              const haveQuery = (searchInput.value || "").trim().length > 0;

              arr.forEach((it) => {
                const row = document.createElement("div");
                row.className = "faq-row";
                row.tabIndex = 0; // keyboard focus accessibility

                // Left: question
                const q = document.createElement("div");
                q.className = "faq-q";
                q.textContent =
                  (it.id ? `${it.id}. ` : "") + (it.question || "(untitled)");

                // Right: preview (empty by default)
                const a = document.createElement("div");
                a.className = "faq-a";
                a.textContent = "";

                // Reveal preview only for the active row (hover/focus); hide on leave/blur
                const showPreview = () => {
                  clearAllPreviews();
                  a.textContent = buildPreview(
                    it.answer,
                    searchInput.value || "",
                  );
                };
                const hidePreview = (evt) => {
                  // If focus moves within the same row, don't clear yet
                  if (
                    evt &&
                    evt.type === "focusout" &&
                    row.contains(evt.relatedTarget)
                  )
                    return;
                  a.textContent = "";
                };

                row.addEventListener("mouseenter", showPreview);
                row.addEventListener("mouseleave", hidePreview);
                row.addEventListener("focusin", showPreview);
                row.addEventListener("focusout", hidePreview);

                // Click anywhere in the row opens the item
                row.onclick = () => showFaqItem(state, it);

                row.appendChild(q);
                row.appendChild(a);
                listEl.appendChild(row);
              });
            }

            const total = allFaqs.length;
            const shown = arr.length;
            countEl.textContent =
              shown === total
                ? `Showing ${total} FAQs`
                : `Showing ${shown} of ${total} FAQs`;

            // Show “Print Filtered” only when a non-empty query is active and we have results
            const activeQuery = (searchInput.value || "").trim().length > 0;
            if (printFilteredBtn) {
              printFilteredBtn.style.display =
                activeQuery && shown > 0 ? "inline-block" : "none";
            }
          }

          // Initial paint
          clearAllPreviews();
          renderList(filtered);

          // Apply filter (uses your global WE.searchItems)
          function applyFilter() {
            filtered = window.WE.searchItems(allFaqs, searchInput.value, [
              "question",
              "answer",
              "categories",
            ]);
            renderList(filtered);
            clearAllPreviews();
          }

          // Debounced typing
          let debounceId;
          searchInput.addEventListener("input", () => {
            clearTimeout(debounceId);
            debounceId = setTimeout(applyFilter, 120);
          });

          // Print just the filtered results
          if (printFilteredBtn) {
            printFilteredBtn.addEventListener("click", () => {
              if (typeof window.printFaqs === "function") {
                window.printFaqs(state, filtered);
              }
            });
          }

          // --- END: FAQ search UI + live filter ---
        };
      })();
    </script>

<!-- =========================================================
     SCRIPT MODULE: User Notes Workspace
     RESPONSIBILITIES:
       - Persist user notes to localStorage under STORAGE_KEY
       - Maintain in-memory notes[] list and currentNoteId
       - Build and manage:
           * Notes ribbon (Tags row + Filters row, 5-column grid)
           * Notes list (saved notes & metadata)
           * Rich text note editor body
       - Tagging:
           * State tag (driven by WE.STATE_NAMES)
           * Manufacturer tag (MANUFACTURERS list)
           * Custom "other" tags
       - Filters:
           * By state, manufacturer, tags, search text
       - Features:
           * New / Save / Delete notes
           * Import / Export JSON for notes
           * Print a single note via printHtmlViaIframe(...)
       - Integrates with app:
           * openNotes() / closeNotes() adjust layout and
             temporarily adjust actions bar behavior.
     TIES TO DOC:
       "Feature modules → User Notes" and "Functional Actions" (notes).
   ========================================================= -->

<script>
      (function () {
   /**
   * User Notes module
   * -----------------
   * [MODULE][LOCAL]
   * - Self-contained feature module wrapped in an IIFE.
   * - Nothing from this block is attached to window.* or WE.*,
   *   so all functions and variables here are LOCAL to User Notes.
   *
   * Responsibilities:
   * - Stores notes in localStorage under STORAGE_KEY.
   * - Each note has: id, title, body (HTML), state, tags, createdAt, updatedAt.
   * - Provides:
   *     - loadNotes() / saveNotes()
   *     - renderNotesList(): left-hand list panel
   *     - ensureNoteForEditing(), saveCurrentNote(): lifecycle of the “current” note
   *     - buildStateOptions(), buildManufacturerOptions(), buildTagFilterOptions(): dropdowns
   *     - openNotes() / closeNotes(): toggled by the “User Notes” button in the notice bar
   * - Also wires up:
   *     - formatting toolbar (bold, italic, lists, etc.)
   *     - special characters popup
   *     - notes-only printing (adds body.notes-printing during print)
   */
 
       // [MODULE CONST][LOCAL]
        // Storage key used for persisting all User Notes in localStorage.
        // Not exposed on window.*; only this module reads/writes this key.
       const STORAGE_KEY = "we_user_notes_v1";

        // [MODULE CONST][LOCAL]
        // Canonical list of OEM / manufacturer names used for note tagging
        // and filtering in the User Notes workspace. 
       const MANUFACTURERS = [
          "Cummins",
          "Eaton",
          "Hino",
          "Isuzu",
          "Kenworth",
          "Mack",
          "Navistar",
          "Paccar",
          "Volvo",
        ].sort();

         // [MODULE STATE][LOCAL]
        // notes:            In-memory array of all note objects loaded from localStorage.
        // currentNoteId:    ID of the note currently being edited/displayed in the editor.
        // originalPrintLabel:
        //    Snapshot of the main "Print" button label + tooltip so we can
        //    temporarily change it while Notes are open, then restore it.
       let notes = [];
        let currentNoteId = null;
        let originalPrintLabel = null;

        // [UTILITY][LOCAL]
        // safeParse(json):
        //   Defensive JSON.parse wrapper. Returns null instead of throwing
        //   if the stored data is malformed or not valid JSON.
        function safeParse(json) {
          try {
            return JSON.parse(json);
          } catch (e) {
            return null;
          }
        }

        // [PERSISTENCE][LOCAL]
        // loadNotes():
        //   Hydrates the in-memory `notes` array from localStorage.
        //   - Uses STORAGE_KEY.
        //   - Tolerates missing or invalid data by falling back to [].
        function loadNotes() {
          const raw = window.localStorage
            ? window.localStorage.getItem(STORAGE_KEY)
            : null;
          const parsed = raw ? safeParse(raw) : null;
          notes = Array.isArray(parsed) ? parsed : [];
        }

        // [PERSISTENCE][LOCAL]
        // saveNotes():
        //   Persists the current `notes` array back to localStorage.
        //   - No global side effects beyond localStorage.
        //   - Fails softly and logs to console on quota/serialization issues.
        function saveNotes() {
          if (!window.localStorage) return;
          try {
            window.localStorage.setItem(STORAGE_KEY, JSON.stringify(notes));
          } catch (e) {
            console.warn("Unable to save notes to localStorage", e);
          }
        }

        // [LOOKUP][LOCAL]
        // getStateMap():
        //   Builds a simple { "KY": "Kentucky", ... } lookup from WE.STATE_NAMES.
        //   - Reads from the global WE namespace but does not modify it.
        //   - Used to populate <select> options for state tagging/filtering.
        function getStateMap() {
          const map = {};
          if (window.WE && WE.STATE_NAMES) {
            Object.keys(WE.STATE_NAMES).forEach((code) => {
              map[String(code).toUpperCase()] = String(WE.STATE_NAMES[code]);
            });
          }
          return map;
        }

        // [UI BUILDER][LOCAL]
        // buildStateOptions(select, includeAllLabel, includeGeneral):
        //   Populates a <select> element with:
        //     - Optional "All states" or similar label.
        //     - Optional "(General / None)" entry.
        //     - One option per known state code from getStateMap().
        //   - Safe no-op if the select element is missing.
        function buildStateOptions(select, includeAllLabel, includeGeneral) {
          if (!select) return;
          const stateMap = getStateMap();
          const codes = Object.keys(stateMap).sort();
          select.innerHTML = "";
          if (includeAllLabel) {
            const optAll = document.createElement("option");
            optAll.value = "";
            optAll.textContent = includeAllLabel;
            select.appendChild(optAll);
          }
          if (includeGeneral) {
            const optGen = document.createElement("option");
            optGen.value = "";
            optGen.textContent = "(General / None)";
            select.appendChild(optGen);
          }
          codes.forEach((code) => {
            const opt = document.createElement("option");
            opt.value = code;
            opt.textContent = stateMap[code] || code;
            select.appendChild(opt);
          });
        }

        // [UI BUILDER][LOCAL]
        // buildManufacturerOptions(select, includeAllLabel, includeNoneLabel):
        //   Populates the OEM/Manufacturer <select> for both tags and filters.
        //   - Uses the MANUFACTURERS array as the canonical list.
        //   - Optional "All OEMs" and "(None)" style entries.
       function buildManufacturerOptions(
          select,
          includeAllLabel,
          includeNoneLabel,
        ) {
          if (!select) return;
          select.innerHTML = "";
          if (includeAllLabel) {
            const optAll = document.createElement("option");
            optAll.value = "";
            optAll.textContent = includeAllLabel;
            select.appendChild(optAll);
          }
          if (includeNoneLabel) {
            const optNone = document.createElement("option");
            optNone.value = "";
            optNone.textContent = includeNoneLabel;
            select.appendChild(optNone);
          }
          MANUFACTURERS.forEach((name) => {
            const opt = document.createElement("option");
            opt.value = name;
            opt.textContent = name;
            select.appendChild(opt);
          });
        }

        // [DATA AGGREGATION][LOCAL]
        // collectAllOtherTags():
        //   Scans all notes and returns a sorted list of unique "other" tags
        //   (free-form user tags). Used to populate the Tag filter dropdown.
        function collectAllOtherTags() {
          const set = new Set();
          notes.forEach((n) => {
            const arr =
              n && n.tags && Array.isArray(n.tags.other) ? n.tags.other : [];
            arr.forEach((t) => {
              const s = String(t || "").trim();
              if (s) set.add(s);
            });
          });
          return Array.from(set).sort((a, b) => a.localeCompare(b));
        }

        // [UI BUILDER][LOCAL]
        // buildTagFilterOptions(select):
        //   Populates the Tag filter <select> with:
        //     - "(All tags)" sentinel
        //     - "(No tags assigned)" sentinel
        //     - One option per unique free-form tag from collectAllOtherTags().
        function buildTagFilterOptions(select) {
          if (!select) return;
          const tags = collectAllOtherTags();
          select.innerHTML = "";
          const optAll = document.createElement("option");
          optAll.value = "";
          optAll.textContent = "All tags";
          select.appendChild(optAll);
          const optNone = document.createElement("option");
          optNone.value = "__none__";
          optNone.textContent = "No tags";
          select.appendChild(optNone);
          tags.forEach((tag) => {
            const opt = document.createElement("option");
            opt.value = tag;
            opt.textContent = tag;
            select.appendChild(opt);
          });
        }

        // [CONTEXT][LOCAL]
        // getCurrentStateCode():
        //   Reads the main Governing State selector (stateSel) and returns
        //   the currently active state code (e.g., "KY").
        //   - Used to pre-tag new notes with the current program state.
        function getCurrentStateCode() {
          const sel = document.getElementById("stateSel");
          return sel && sel.value ? String(sel.value).toUpperCase() : "";
        }

        // [NOTE LOOKUP][LOCAL]
        // findNoteIndex(id):
        //   Utility to locate a note by id within the in-memory `notes` array.
        //   Returns the numeric index, or -1 if not found. 
       function findNoteIndex(id) {
          return notes.findIndex((n) => String(n.id) === String(id));
        }

        function getStateLabel(code) {
          if (!code) return "";
          const map = getStateMap();
          return map[code] || code;
        }

        function ensureNoteForEditing(
          noteTitleInput,
          noteBody,
          noteStateTag,
          noteManufacturerTag,
          noteOtherTagsInput,
        ) {
          if (currentNoteId && findNoteIndex(currentNoteId) >= 0) return;

          const now = new Date().toISOString();
          const defaultState = getCurrentStateCode();
          const note = {
            id: "n_" + Date.now() + "_" + Math.floor(Math.random() * 100000),
            title:
              (noteTitleInput && noteTitleInput.value.trim()) ||
              "Untitled note",
            body: (noteBody && noteBody.innerHTML) || "",
            state: defaultState || "",
            tags: {
              manufacturers: [],
              other: [],
            },
            createdAt: now,
            updatedAt: now,
          };
          notes.unshift(note);
          currentNoteId = note.id;

          if (noteStateTag) {
            noteStateTag.value = note.state || "";
          }
          if (noteManufacturerTag) {
            noteManufacturerTag.value = "";
          }
          if (noteOtherTagsInput) {
            noteOtherTagsInput.value = "";
          }
          saveNotes();
        }

        function readTagsFromInput(input) {
          if (!input) return [];
          return String(input.value || "")
            .split(",")
            .map((s) => s.trim())
            .filter((s) => s.length > 0);
        }

        // [NOTE LIFECYCLE][LOCAL]
        // syncEditorToNote(note, ...):
        //   Copies the fields from a note object into the editor controls:
        //   - Title, body HTML, state tag, OEM tag, and other tags text.
       function syncEditorToNote(
          note,
          noteTitleInput,
          noteBody,
          noteStateTag,
          noteManufacturerTag,
          noteOtherTagsInput,
        ) {
          if (!note) return;
          if (noteTitleInput) {
            noteTitleInput.value = note.title || "";
          }
          if (noteBody) {
            noteBody.innerHTML = note.body || "";
          }
          if (noteStateTag) {
            noteStateTag.value = note.state || "";
          }
          if (noteManufacturerTag) {
            const arr =
              note.tags && Array.isArray(note.tags.manufacturers)
                ? note.tags.manufacturers
                : [];
            noteManufacturerTag.value = arr[0] || "";
          }
          if (noteOtherTagsInput) {
            const arr =
              note.tags && Array.isArray(note.tags.other)
                ? note.tags.other
                : [];
            noteOtherTagsInput.value = arr.join(", ");
          }
        }

        // [NOTE LIFECYCLE][LOCAL]
        // saveCurrentNote(...):
        //   Reads values from the editor controls and writes them back into
        //   the current note object, updating timestamps and calling saveNotes().
        //   - Safe no-op if there is no currentNoteId yet.
        function saveCurrentNote(
          noteTitleInput,
          noteBody,
          noteStateTag,
          noteManufacturerTag,
          noteOtherTagsInput,
        ) {
          if (!currentNoteId) return;
          const idx = findNoteIndex(currentNoteId);
          if (idx < 0) return;
          const note = notes[idx];
          if (noteTitleInput) {
            note.title = noteTitleInput.value.trim() || "Untitled note";
          }
          if (noteBody) {
            note.body = noteBody.innerHTML;
          }
          if (noteStateTag) {
            note.state = noteStateTag.value || "";
          }
          if (noteManufacturerTag) {
            const m = noteManufacturerTag.value || "";
            note.tags = note.tags || {};
            note.tags.manufacturers = m ? [m] : [];
          }
          if (noteOtherTagsInput) {
            note.tags = note.tags || {};
            note.tags.other = readTagsFromInput(noteOtherTagsInput);
          }
          note.updatedAt = new Date().toISOString();
          saveNotes();
        }

        // [UI RENDER][LOCAL]
        // renderNotesList(container, stateFilter, manufacturerFilter, tagFilter):
        //   Renders the left-hand list of notes, applying any active filters.
        //   - Highlights the current note (by currentNoteId).
        //   - Attaches click handlers to switch the active note.
       function renderNotesList(
          container,
          stateFilterSel,
          manufFilterSel,
          tagFilterSel,
        ) {
          if (!container) return;
          container.innerHTML = "";

          const stateFilter = stateFilterSel ? stateFilterSel.value : "";
          const manufFilter = manufFilterSel ? manufFilterSel.value : "";
          const tagFilterVal = tagFilterSel ? tagFilterSel.value : "";

          // Copy notes and sort by creation time (newest first)
          let list = notes.slice().sort(function (a, b) {
            const aTime = a && a.createdAt ? Date.parse(a.createdAt) || 0 : 0;
            const bTime = b && b.createdAt ? Date.parse(b.createdAt) || 0 : 0;
            return bTime - aTime;
          });

          if (stateFilter) {
            list = list.filter((n) => (n.state || "") === stateFilter);
          }
          if (manufFilter) {
            list = list.filter((n) => {
              const arr =
                n.tags && Array.isArray(n.tags.manufacturers)
                  ? n.tags.manufacturers
                  : [];
              return arr.includes(manufFilter);
            });
          }
          if (tagFilterVal) {
            if (tagFilterVal === "__none__") {
              list = list.filter((n) => {
                const arr =
                  n.tags && Array.isArray(n.tags.other) ? n.tags.other : [];
                return !arr.length;
              });
            } else {
              list = list.filter((n) => {
                const arr =
                  n.tags && Array.isArray(n.tags.other) ? n.tags.other : [];
                return arr.includes(tagFilterVal);
              });
            }
          }

          if (!list.length) {
            const empty = document.createElement("div");
            empty.className = "notes-list-empty";
            empty.textContent =
              'No notes yet. Click "New" to create one, or adjust filters.';
            container.appendChild(empty);
            return;
          }

          list.forEach((note) => {
            const btn = document.createElement("button");
            btn.type = "button";
            btn.className =
              "notes-list-item" + (note.id === currentNoteId ? " active" : "");
            btn.setAttribute("data-id", note.id);

            const title = document.createElement("div");
            title.className = "notes-list-title";
            title.textContent = note.title || "Untitled note";

            const meta = document.createElement("div");
            meta.className = "notes-list-meta";
            const stateCode = note.state || "";
            const stateAbbrev = stateCode;
            const manufArr =
              note.tags && Array.isArray(note.tags.manufacturers)
                ? note.tags.manufacturers
                : [];
            const otherArr =
              note.tags && Array.isArray(note.tags.other)
                ? note.tags.other
                : [];
            const parts = [];
            if (stateAbbrev) parts.push(stateAbbrev);
            if (manufArr.length) parts.push(manufArr[0]);
            if (otherArr.length) parts.push(otherArr.join(", "));
            meta.textContent = parts.join(" • ");

            btn.appendChild(title);
            btn.appendChild(meta);
            container.appendChild(btn);
          });
          return list;
        }
// Returns the notes that match the current filters (state, OEM, tag)
function getFilteredNotes(stateFilterSel, manufFilterSel, tagFilterSel) {
  const stateFilter = stateFilterSel ? stateFilterSel.value : "";
  const manufFilter = manufFilterSel ? manufFilterSel.value : "";
  const tagFilterVal = tagFilterSel ? tagFilterSel.value : "";

  // Start with all notes, newest first
  let list = notes.slice().sort(function (a, b) {
    const aTime = a && a.createdAt ? Date.parse(a.createdAt) || 0 : 0;
    const bTime = b && b.createdAt ? Date.parse(b.createdAt) || 0 : 0;
    return bTime - aTime;
  });

  if (stateFilter) {
    list = list.filter((n) => (n.state || "") === stateFilter);
  }
  if (manufFilter) {
    list = list.filter((n) => {
      const arr =
        n.tags && Array.isArray(n.tags.manufacturers)
          ? n.tags.manufacturers
          : [];
      return arr.includes(manufFilter);
    });
  }
  if (tagFilterVal) {
    if (tagFilterVal === "__none__") {
      list = list.filter((n) => {
        const arr =
          n.tags && Array.isArray(n.tags.other) ? n.tags.other : [];
        return !arr.length;
      });
    } else {
      list = list.filter((n) => {
        const arr =
          n.tags && Array.isArray(n.tags.other) ? n.tags.other : [];
        return arr.includes(tagFilterVal);
      });
    }
  }

  return list;
}

        // [EDITOR][LOCAL]
        // applyFormat(cmd, value):
        //   Thin wrapper around document.execCommand for basic rich-text
        //   formatting in the note body (bold, italic, lists, etc.).
        //   - Called by toolbar buttons with data-format attributes.
        function applyFormat(cmd, value) {
          try {
            const body = document.getElementById("noteBody");
            if (body) body.focus();
            document.execCommand(cmd, false, value || null);
          } catch (e) {
            console.warn("Formatting not supported", cmd, e);
          }
        }

        // [EDITOR][LOCAL]
        // insertSpecialChar(ch):
        //   Inserts a single character (or small string) at the caret inside
        //   the note body. Used by the "special characters" popup.
        function insertSpecialChar(ch) {
          try {
            const body = document.getElementById("noteBody");
            if (body) body.focus();
            if (
              document.queryCommandSupported &&
              document.queryCommandSupported("insertText")
            ) {
              document.execCommand("insertText", false, ch);
            } else {
              document.execCommand("insertHTML", false, ch);
            }
          } catch (e) {
            console.warn("Unable to insert special char", ch, e);
          }
        }

        // [INIT][LOCAL]
        // DOMContentLoaded handler for User Notes:
        //   - Grabs all DOM handles for the notes workspace.
        //   - Calls loadNotes() and seeds dropdowns and filters.
        //   - Wires up buttons (New, Save, Delete, Print, Export, Import).
        //   - Wires up formatting toolbar and special characters menu.
        document.addEventListener("DOMContentLoaded", function () {
          const notesWorkspace = document.getElementById("notesWorkspace");
          const userNotesBtn = document.getElementById("userNotesBtn");
          const notesCloseBtn = document.getElementById("notesCloseBtn");

          const notesNewBtn = document.getElementById("notesNewBtn");
          const notesSaveBtn = document.getElementById("notesSaveBtn");
          const notesDeleteBtn = document.getElementById("notesDeleteBtn");
          const notesPrintBtn = document.getElementById("notesPrintBtn");
          const notesExportBtn = document.getElementById("notesExportBtn");
          const notesImportBtn = document.getElementById("notesImportBtn");

          const noteTitleInput = document.getElementById("noteTitleInput");
          const noteBody = document.getElementById("noteBody");
          const noteStateTag = document.getElementById("noteStateTag");
          const noteManufacturerTag = document.getElementById(
            "noteManufacturerTag",
          );
          const noteOtherTagsInput =
            document.getElementById("noteOtherTagsInput");

          const notesList = document.getElementById("notesList");
          const notesStateFilter = document.getElementById("notesStateFilter");
          const notesManufacturerFilter = document.getElementById(
            "notesManufacturerFilter",
          );
          const notesTagFilter = document.getElementById("notesTagFilter");

          const specialCharBtn = document.getElementById("notesSpecialCharBtn");
          const specialCharMenu = document.getElementById(
            "notesSpecialCharMenu",
          );

          const formatButtons = Array.from(
            document.querySelectorAll(".notes-format-btn"),
          );

          // Action buttons in the row above User Notes
          // (used so we can disable them while Notes are open)
          const copyBtn = document.getElementById("copyBtn");
          const printBtn = document.getElementById("printBtn");
          const printAllBtn = document.getElementById("printAllBtn");

          if (!notesWorkspace || !userNotesBtn) return;

          loadNotes();

          buildStateOptions(noteStateTag, null, true);
          buildStateOptions(notesStateFilter, "All states", false);
          buildManufacturerOptions(noteManufacturerTag, null, "(None)");
          buildManufacturerOptions(
            notesManufacturerFilter,
            "All OEMs",
            "(No OEM specified)",
          );
          buildTagFilterOptions(notesTagFilter);
          renderNotesList(
            notesList,
            notesStateFilter,
            notesManufacturerFilter,
            notesTagFilter,
          );

          // Allow Tab inside note body to insert spaces instead of changing focus
          if (noteBody) {
            noteBody.addEventListener("keydown", function (evt) {
              if (evt.key === "Tab") {
                evt.preventDefault();
                insertSpecialChar("    ");
              }
            });
          }
function handleFilterChange() {
  // First, compute which notes *should* be visible
  const filtered = getFilteredNotes(
    notesStateFilter,
    notesManufacturerFilter,
    notesTagFilter,
  );

  // Then re-render the list UI based on current filters
  renderNotesList(
    notesList,
    notesStateFilter,
    notesManufacturerFilter,
    notesTagFilter,
  );

  // If the current note is still in the filtered set, we're done
  if (
    currentNoteId &&
    filtered.some((n) => String(n.id) === String(currentNoteId))
  ) {
    return;
  }

  // If there are matching notes, switch to the first one
  if (filtered.length > 0) {
    const next = filtered[0];
    currentNoteId = next.id;
    syncEditorToNote(
      next,
      noteTitleInput,
      noteBody,
      noteStateTag,
      noteManufacturerTag,
      noteOtherTagsInput,
    );

    // Ensure active highlight matches the new current note
    renderNotesList(
      notesList,
      notesStateFilter,
      notesManufacturerFilter,
      notesTagFilter,
    );
    return;
  }

  // *** IMPORTANT CASE ***
  // No notes match the filters → clear the editor entirely
  currentNoteId = null;
  if (noteTitleInput) noteTitleInput.value = "";
  if (noteBody) noteBody.innerHTML = "";
  if (noteStateTag) noteStateTag.value = "";
  if (noteManufacturerTag) noteManufacturerTag.value = "";
  if (noteOtherTagsInput) noteOtherTagsInput.value = "";
}
          // [UI STATE][LOCAL]
          // updatePrintLabelForNotes(open):
          // In User Notes mode we disable the right-side action buttons
          // (Copy / Print / Print All) so that printing and copying for notes
          // happens only through the controls inside the Notes ribbon.
          // Restores buttons when Notes are closed.
          function updatePrintLabelForNotes(open) {
            const shouldDisable = !!open;
            [copyBtn, printBtn, printAllBtn].forEach((btn) => {
              if (!btn) return;
              if (shouldDisable) {
                btn.disabled = true;
                btn.setAttribute("aria-disabled", "true");
              } else {
                btn.disabled = false;
                btn.removeAttribute("aria-disabled");
              }
            });
          }

          // [MODE SWITCH][LOCAL]
          // openNotes():
          //   Shows the User Notes workspace panel:
          //   - Unhides the workspace and adds body.notes-open.
          //   - Updates the main Print button label for "Print / Save Notes".
          //   - If there are existing notes and none active yet, selects the first. 
         function openNotes() {
  notesWorkspace.hidden = false;
  notesWorkspace.style.display = "";  // let CSS take over again

  document.body.classList.add("notes-open");
  updatePrintLabelForNotes(true);

  // If there are notes but none selected yet, load the first one
  if (!currentNoteId && notes.length > 0) {
    currentNoteId = notes[0].id;
    syncEditorToNote(
      notes[0],
      noteTitleInput,
      noteBody,
      noteStateTag,
      noteManufacturerTag,
      noteOtherTagsInput,
    );
    renderNotesList(
      notesList,
      notesStateFilter,
      notesManufacturerFilter,
      notesTagFilter,
    );
  }
}

          // [MODE SWITCH][LOCAL]
          // closeNotes():
          //   Hides the User Notes workspace panel:
          //   - Attempts to save the current note (fails softly).
          //   - Hides the workspace and removes body.notes-open.
          //   - Restores the main Print button label/tooltip.
          function closeNotes() {
             // Try to save, but don't let an error block closing the panel
            try {
              saveCurrentNote(
                noteTitleInput,
                noteBody,
                noteStateTag,
                noteManufacturerTag,
                noteOtherTagsInput,
              );
            } catch (e) {
              console.warn("saveCurrentNote failed during closeNotes", e);
            }

             // Belt + suspenders: hide via both [hidden] and inline style
                notesWorkspace.hidden = true;
                notesWorkspace.style.display = "none";

                document.body.classList.remove("notes-open");
                updatePrintLabelForNotes(false);
          }
 
         // [EVENTS][LOCAL]
          // Notes workspace toggles:
          //   - userNotesBtn: toggles open/close of the notes panel.
          //   - notesCloseBtn (big X): closes the panel and saves current note.
          userNotesBtn.addEventListener("click", function () {
            if (notesWorkspace.hidden) {
              openNotes();
            } else {
              closeNotes();
            }
          });

          if (notesCloseBtn) {
            notesCloseBtn.addEventListener("click", closeNotes);
          }
          // [EVENTS][LOCAL]
          // CRUD buttons:
          //   - New:   Saves the current note (if any), then creates/selects a new blank note.
          //   - Save:  Writes current editor fields back into the active note and persists.
          //   - Delete:Removes the active note (with confirmation) and re-renders the list.
          if (notesNewBtn) {
            notesNewBtn.addEventListener("click", function () {
              saveCurrentNote(
                noteTitleInput,
                noteBody,
                noteStateTag,
                noteManufacturerTag,
                noteOtherTagsInput,
              );
              const now = new Date().toISOString();
              const defaultState = getCurrentStateCode();
              const newNote = {
                id:
                  "n_" + Date.now() + "_" + Math.floor(Math.random() * 100000),
                title: "Untitled note",
                body: "",
                state: defaultState || "",
                tags: {
                  manufacturers: [],
                  other: [],
                },
                createdAt: now,
                updatedAt: now,
              };
              notes.unshift(newNote);
              currentNoteId = newNote.id;
              syncEditorToNote(
                newNote,
                noteTitleInput,
                noteBody,
                noteStateTag,
                noteManufacturerTag,
                noteOtherTagsInput,
              );
              buildTagFilterOptions(notesTagFilter);
              renderNotesList(
                notesList,
                notesStateFilter,
                notesManufacturerFilter,
                notesTagFilter,
              );
            });
          }

          if (notesSaveBtn) {
            notesSaveBtn.addEventListener("click", function () {
              ensureNoteForEditing(
                noteTitleInput,
                noteBody,
                noteStateTag,
                noteManufacturerTag,
                noteOtherTagsInput,
              );
              saveCurrentNote(
                noteTitleInput,
                noteBody,
                noteStateTag,
                noteManufacturerTag,
                noteOtherTagsInput,
              );
              buildTagFilterOptions(notesTagFilter);
              renderNotesList(
                notesList,
                notesStateFilter,
                notesManufacturerFilter,
                notesTagFilter,
              );
            });
          }

          if (notesDeleteBtn) {
            notesDeleteBtn.addEventListener("click", function () {
              if (!currentNoteId) return;
              const idx = findNoteIndex(currentNoteId);
              if (idx < 0) return;
              notes.splice(idx, 1);
              saveNotes();
              currentNoteId = null;
              if (noteTitleInput) noteTitleInput.value = "";
              if (noteBody) noteBody.innerHTML = "";
              if (noteStateTag) noteStateTag.value = "";
              if (noteManufacturerTag) noteManufacturerTag.value = "";
              if (noteOtherTagsInput) noteOtherTagsInput.value = "";
              buildTagFilterOptions(notesTagFilter);
              renderNotesList(
                notesList,
                notesStateFilter,
                notesManufacturerFilter,
                notesTagFilter,
              );
            });
          }

          // [EVENTS][LOCAL]
          // Notes-specific actions:
          //   - Print:   Builds a dedicated print HTML just for the active note.
          //   - Export:  Serializes the active note to a portable JSON file (.we-note.json).
          //   - Import:  Reads a JSON note file from disk and adds it to the local notes list.
          if (notesPrintBtn) {
            notesPrintBtn.addEventListener("click", function () {
              if (!currentNoteId) return;
              const idx = findNoteIndex(currentNoteId);
              if (idx < 0) return;
              const note = notes[idx];

              const esc = (s) =>
                String(s ?? "").replace(
                  /[&<>"]/g,
                  (m) =>
                    ({ "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;" })[
                      m
                    ],
                );

              const stateCode = note.state || "";
              const stateLabel = getStateLabel(stateCode);
              const manufArr =
                note.tags && Array.isArray(note.tags.manufacturers)
                  ? note.tags.manufacturers
                  : [];
              const otherArr =
                note.tags && Array.isArray(note.tags.other)
                  ? note.tags.other
                  : [];

              const tagLineParts = [];
              if (stateLabel) tagLineParts.push(stateLabel);
              if (manufArr.length) tagLineParts.push(manufArr[0]);
              if (otherArr.length) tagLineParts.push(otherArr.join(", "));
              const tagLine = tagLineParts.join(" • ");

              const bodyHtml = note.body || "";

              const html = `<!doctype html><html><head><meta charset="utf-8">
<title>${esc(note.title || "User Note")}</title>
<style>
  :root{ --brand-red:#bc3737; --ink:#111; }
  body{ font-family:system-ui,Arial,sans-serif; color:var(--ink); margin:24px; }
  h1{ margin:0 0 6px 0; font-size:1.3rem; }
  .underline{ height:3px; background:var(--brand-red); border-radius:2px; margin:4px 0 10px; }
  .meta{ font-size:.9rem; color:#555; margin-bottom:10px; }
  .note-body{ font-size:.95rem; }

   
</style></head><body>
  <h1>${esc(note.title || "User Note")}</h1>
  <div class="underline"></div>
  ${tagLine ? `<div class="meta">${esc(tagLine)}</div>` : ""}
  <div class="note-body">${bodyHtml}</div>
</body></html>`;

              if (typeof printHtmlViaIframe === "function") {
                printHtmlViaIframe(html);
              } else {
                const w = window.open("", "_blank");
                if (!w) return;
                w.document.open();
                w.document.write(html);
                w.document.close();
                w.focus();
                w.print();
              }
            });
          }
if (notesExportBtn) {
  notesExportBtn.addEventListener("click", function () {
    if (!currentNoteId) return;
    const idx = findNoteIndex(currentNoteId);
    if (idx < 0) return;
    const note = notes[idx];

    // Build a portable JSON payload
    const payload = {
      we_note_version: 1,
      title: note.title || "Untitled note",
      body_html: note.body || "",
      state: note.state || "",
      tags: {
        manufacturers:
          note.tags && Array.isArray(note.tags.manufacturers)
            ? note.tags.manufacturers
            : [],
        other:
          note.tags && Array.isArray(note.tags.other)
            ? note.tags.other
            : [],
      },
      createdAt: note.createdAt || null,
      updatedAt: note.updatedAt || null,
    };

    // Create a reasonably safe filename
    const stateCode = payload.state || "GEN";
    const rawTitle = payload.title || "Note";
    const safeTitle = rawTitle
      .replace(/[^A-Za-z0-9]+/g, "_")
      .replace(/^_+|_+$/g, "")
      .slice(0, 40) || "Note";
    const ts = new Date().toISOString().replace(/[:.]/g, "-");
    const fileName = `WE-Note_${stateCode}_${safeTitle}_${ts}.we-note.json`;

    const json = JSON.stringify(payload, null, 2);
    const blob = new Blob([json], { type: "application/json" });
    const url = URL.createObjectURL(blob);

    const a = document.createElement("a");
    a.href = url;
    a.download = fileName;
    document.body.appendChild(a);
    a.click();
    setTimeout(function () {
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }, 0);
  });
}
if (notesImportBtn) {
  notesImportBtn.addEventListener("click", function () {
    // Create a temporary file input
    const input = document.createElement("input");
    input.type = "file";
    input.accept = ".json,application/json,.we-note.json";

    input.addEventListener("change", function () {
      const file = input.files && input.files[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = function (evt) {
        try {
          const text = String(evt.target.result || "");
          const data = JSON.parse(text);

          if (!data || typeof data !== "object") {
            alert("That file does not contain a valid note.");
            return;
          }
          if (data.we_note_version !== 1 && data.we_note_version !== undefined) {
            // We only know how to handle version 1 (or no version)
            alert(
              "This note file has an unsupported version and cannot be imported.",
            );
            return;
          }

          // Build a new local note object
          const now = new Date().toISOString();
          const newId =
            "n_" + Date.now() + "_" + Math.floor(Math.random() * 100000);

          const importedState =
            (data.state && String(data.state).toUpperCase()) || "";
          const defaultState = getCurrentStateCode();

          const importedTags = data.tags || {};
          const manufacturers = Array.isArray(importedTags.manufacturers)
            ? importedTags.manufacturers
            : [];
          const otherTags = Array.isArray(importedTags.other)
            ? importedTags.other
            : [];

          const newNote = {
            id: newId,
            title: (data.title && String(data.title)) || "Untitled note",
            body: (data.body_html && String(data.body_html)) || "",
            state: importedState || defaultState,
            tags: {
              manufacturers: manufacturers,
              other: otherTags,
            },
            createdAt: data.createdAt || now,
            updatedAt: now,
          };

          // Add to the front of the list, like a new note
          notes.unshift(newNote);
          currentNoteId = newId;
          saveNotes();

          // Refresh filters & list
          buildTagFilterOptions(notesTagFilter);
          renderNotesList(
            notesList,
            notesStateFilter,
            notesManufacturerFilter,
            notesTagFilter,
          );

          // Sync editor to the imported note so the user sees it immediately
          syncEditorToNote(
            newNote,
            noteTitleInput,
            noteBody,
            noteStateTag,
            noteManufacturerTag,
            noteOtherTagsInput,
          );
        } catch (err) {
          console.error("Error importing note file:", err);
          alert(
            "There was a problem reading that note file. It may not be a valid export.",
          );
        }
      };

      reader.readAsText(file);
    });

    // Trigger the file chooser
    input.click();
  });
}

          if (notesList) {
            notesList.addEventListener("click", function (evt) {
              const btn = evt.target.closest(".notes-list-item");
              if (!btn) return;
              const id = btn.getAttribute("data-id");
              if (!id || id === currentNoteId) return;
              saveCurrentNote(
                noteTitleInput,
                noteBody,
                noteStateTag,
                noteManufacturerTag,
                noteOtherTagsInput,
              );
              currentNoteId = id;
              const idx = findNoteIndex(currentNoteId);
              const note = idx >= 0 ? notes[idx] : null;
              syncEditorToNote(
                note,
                noteTitleInput,
                noteBody,
                noteStateTag,
                noteManufacturerTag,
                noteOtherTagsInput,
              );
              renderNotesList(
                notesList,
                notesStateFilter,
                notesManufacturerFilter,
                notesTagFilter,
              );
            });
          }

if (notesStateFilter) {
  notesStateFilter.addEventListener("change", handleFilterChange);
}
if (notesManufacturerFilter) {
  notesManufacturerFilter.addEventListener("change", handleFilterChange);
}
if (notesTagFilter) {
  notesTagFilter.addEventListener("change", handleFilterChange);
}

          // [EVENTS][LOCAL]
          // Formatting toolbar:
          //   - Each .notes-format-btn carries data-format / data-value attributes.
          //   - On click, calls applyFormat(...) to update the note body.
          formatButtons.forEach((btn) => {
            btn.addEventListener("click", function () {
              const cmd = btn.getAttribute("data-cmd");
              if (!cmd) return;
              applyFormat(cmd);
            });
          });

          // [EVENTS][LOCAL]
          // Special characters popup:
          //   - Toggles visibility of the menu.
          //   - Inserts the chosen character into the note body.
          //   - Clicks outside the menu close it automatically.
          if (specialCharBtn && specialCharMenu) {
            specialCharBtn.addEventListener("click", function () {
              const isHidden = specialCharMenu.hasAttribute("hidden");
              if (isHidden) {
                specialCharMenu.removeAttribute("hidden");
              } else {
                specialCharMenu.setAttribute("hidden", "hidden");
              }
            });
            specialCharMenu.addEventListener("click", function (evt) {
              const b = evt.target.closest("button[data-char]");
              if (!b) return;
              const ch = b.getAttribute("data-char") || "";
              if (ch) {
                insertSpecialChar(ch);
              }
              specialCharMenu.setAttribute("hidden", "hidden");
            });
            document.addEventListener("click", function (evt) {
              if (!specialCharMenu.hasAttribute("hidden")) {
                const inside =
                  evt.target.closest("#notesSpecialCharBtn") ||
                  evt.target.closest("#notesSpecialCharMenu");
                if (!inside) {
                  specialCharMenu.setAttribute("hidden", "hidden");
                }
              }
            });
          }
        });
      })();
    </script>
<script>
  // Global keyboard handler for FAQ navigation + admin modals + topic pills
  document.addEventListener("keydown", function (evt) {
    const key = evt.key;

    // Only care about a small set of keys
    if (
      key !== "ArrowRight" &&
      key !== "ArrowLeft" &&
      key !== "ArrowUp" &&
      key !== "ArrowDown" &&
      key !== "Enter" &&
      key !== "Escape" &&
      key !== " "
    ) {
      return;
    }

    // 0) If an admin edit modal is open, give it priority:
    //    Esc = Cancel, Ctrl/Cmd+Enter = Save
    const topicModal = document.getElementById("adminEditModal");
    const faqModal = document.getElementById("adminFaqModal");
    const topicModalOpen = topicModal && !topicModal.hidden;
    const faqModalOpen = faqModal && !faqModal.hidden;

    if (topicModalOpen || faqModalOpen) {
      // Cancel with Escape
      if (key === "Escape") {
        const cancelBtn = topicModalOpen
          ? document.getElementById("adminEditCancel")
          : document.getElementById("adminFaqCancelBtn");
        if (cancelBtn) {
          cancelBtn.click();
          evt.preventDefault();
        }
        return;
      }

      // Save with Ctrl+Enter / Cmd+Enter
      if ((evt.ctrlKey || evt.metaKey) && key === "Enter") {
        const saveBtn = topicModalOpen
          ? document.getElementById("adminEditSave")
          : document.getElementById("adminFaqSaveBtn");
        if (saveBtn) {
          saveBtn.click();
          evt.preventDefault();
        }
        return;
      }

      // For all other keys while a modal is open, do NOT run nav;
      // let them behave normally (e.g., arrows inside textarea).
      return;
    }

    // 1) No modal: now decide if we should do navigation.
    const target = evt.target;
    const tag = target && target.tagName;
    const inEditable =
      target &&
      (target.isContentEditable ||
        tag === "INPUT" ||
        tag === "TEXTAREA" ||
        tag === "SELECT");

    // ===== Topic pills (topics mode) =====
    // When in topics mode, let Left/Right move between topic pills.
    if (window.CURRENT_MODE === "topics") {
      if (key === "ArrowRight" || key === "ArrowLeft") {
        const container = document.getElementById("topicBtns");
        if (!container) return;

        const pills = Array.from(
          container.querySelectorAll(".topic-pill"),
        );
        if (!pills.length) return;

        // Try: pill under current focus
        let currentPill =
          target && target.closest
            ? target.closest(".topic-pill")
            : null;

        // Fallback: currently active pill, or first pill
        if (!currentPill) {
          currentPill =
            container.querySelector(".topic-pill.active") ||
            pills[0];
        }

        const idx = pills.indexOf(currentPill);
        if (idx === -1) return;

        let nextIndex;
        if (key === "ArrowRight") {
          nextIndex = (idx + 1) % pills.length;
        } else {
          nextIndex = (idx - 1 + pills.length) % pills.length;
        }

        const nextPill = pills[nextIndex];
        if (nextPill) {
          if (typeof nextPill.focus === "function") nextPill.focus();
          if (typeof nextPill.click === "function") nextPill.click();
          evt.preventDefault();
        }
        return;
      }
    }

    // If we're typing into an input/textarea/select and not in a modal, don't hijack keys
    if (inEditable) return;

    // ===== Single-FAQ view =====
    if (window.CURRENT_MODE === "faq-item") {
      // Next / previous FAQ via arrows or Enter
      if (
        typeof window.navigateFaqRelative === "function" &&
        (key === "ArrowRight" || key === "ArrowDown" || key === "Enter")
      ) {
        window.navigateFaqRelative(1); // next FAQ (wraps)
        evt.preventDefault();
        return;
      }

      if (
        typeof window.navigateFaqRelative === "function" &&
        (key === "ArrowLeft" || key === "ArrowUp")
      ) {
        window.navigateFaqRelative(-1); // previous FAQ (wraps)
        evt.preventDefault();
        return;
      }

      // Escape: go back to full FAQ list for current state
      if (key === "Escape") {
        const stateSel = document.getElementById("stateSel");
        const stateKey =
          (stateSel && stateSel.value) ||
          (window.WE &&
            (WE.CURRENT_STATE || WE.LAST_STATE || WE.DEFAULT_STATE)) ||
          "";

        if (stateKey && typeof window.showFaqList === "function") {
          window.showFaqList(stateKey);
          evt.preventDefault();
        }
        return;
      }

      return; // done in faq-item mode
    }

    // ===== FAQ list view =====
    if (window.CURRENT_MODE === "faq-list") {
      const mount = document.getElementById("faqMount");
      if (!mount) return;

      const rows = Array.from(
        mount.querySelectorAll(".faq-grid .faq-row"),
      );
      if (!rows.length) return;

      const currentRow =
        target && target.closest ? target.closest(".faq-row") : null;
      let idx = rows.indexOf(currentRow);

      if (key === "ArrowDown") {
        const next = rows[idx + 1] || rows[0];
        if (next && typeof next.focus === "function") {
          next.focus();
          evt.preventDefault();
        }
        return;
      }

      if (key === "ArrowUp") {
        const prev = rows[idx - 1] || rows[rows.length - 1];
        if (prev && typeof prev.focus === "function") {
          prev.focus();
          evt.preventDefault();
        }
        return;
      }

      if (key === "Enter" || key === " ") {
        // If focus is on a row, treat Enter/Space like click; otherwise open first row
        const rowToOpen = currentRow || rows[0];
        if (rowToOpen && typeof rowToOpen.click === "function") {
          rowToOpen.click();
          evt.preventDefault();
        }
        return;
      }

      // Esc in faq-list mode falls through (no special handling here).
    }
  });
</script>


<script>
  // Admin export button: enable/disable + tooltip based on WE.ADMIN_UPDATE_NEEDED
  /**
   * updateAdminExportButtonState (global)
   * -------------------------------------
   * - Global helper: attached as window.updateAdminExportButtonState.
   * - Reads WE.ADMIN_UPDATE_NEEDED:
   *     - true  → button is bright green, enabled, and clickable.
   *     - false → button is greyed out and disabled.
   * - Also sets a descriptive tooltip/aria-label via data-tip.
   *
   * Called by:
   *   - enterAdminMode() when the admin controls are first created.
   *   - Topic / FAQ admin editors after a successful save
   *     (to mark that an updated Excel export is available).
   *   - exportUpdatedExcel() after a successful export
   *     (to clear the dirty flag and disable the button).
   */
  function updateAdminExportButtonState() {
    const btn = document.getElementById("adminExportBtn");
    if (!btn) return;

    window.WE = window.WE || {};
    const needed = !!WE.ADMIN_UPDATE_NEEDED;

    // Local tooltip helper (mirrors other data-tip usage)
    const setTip = (tip) => {
      btn.setAttribute("data-tip", tip);
      btn.setAttribute("aria-label", tip);
      btn.removeAttribute("title");
    };

    if (needed) {
      // Changes pending → bright green, clickable
      btn.disabled = false;
      btn.style.background = "#2e7d32";
      btn.style.borderColor = "#2e7d32";
      btn.style.color = "#ffffff";
      btn.style.cursor = "pointer";
      btn.style.opacity = "1";
      setTip("Download updated Excel workbook to your downloads folder");
    } else {
      // No changes → greyed, not clickable
      btn.disabled = true;
      btn.style.background = "#e5e7eb";
      btn.style.borderColor = "#d1d5db";
      btn.style.color = "#6b7280";
      btn.style.cursor = "default";
      btn.style.opacity = "0.7";
      setTip("No changes to export");
    }
  }

  // Expose on window so other scripts can call it safely
  window.updateAdminExportButtonState = updateAdminExportButtonState;
</script>


<script>
// =======================================================
//  EXPORT UPDATED EXCEL WORKBOOK (MasterLegalData_UPDATED.xlsx)
// =======================================================
//  Uses WE_CTX (loaded from sessionStorage by the payload bootstrap)
//  to reconstruct a workbook with sheets:
//    - _Meta
//    - _Topics
//    - _Rows
//    - _States
//    - One sheet per state (state code as sheet name)
//    - FAQs
//    - EXTRA_SHEETS (if present on ctx)
// =======================================================
// Global admin/export function (invoked by the green Excel button in admin mode)
// Exposed as window.exportUpdatedExcel so other modules can call it.
window.exportUpdatedExcel = function () {
  // Use the same date-parsing logic the app already uses (parseMetaDate + excelSerialToDate)
  function exportMetaDateCell(raw) {
    const d = typeof parseMetaDate === "function" ? parseMetaDate(raw) : null;
    if (d) {
      // Format as MM/DD/YYYY in UTC, same as formatMDYUTC
      if (typeof formatMDYUTC === "function") {
        return formatMDYUTC(d);
      }
      // Fallback if formatMDYUTC not available
      const pad = (n) => (n < 10 ? "0" : "") + n;
      return `${pad(d.getUTCMonth() + 1)}/${pad(d.getUTCDate())}/${d.getUTCFullYear()}`;
    }
    return raw == null ? "" : String(raw);
  }
  function pickField(obj, candidates) {
    if (!obj || !candidates || !candidates.length) return "";
    for (var i = 0; i < candidates.length; i++) {
      var k = candidates[i];
      if (k in obj && obj[k] != null && obj[k] !== "") {
        return obj[k];
      }
    }
    return "";
  }

  if (typeof XLSX === "undefined") {
    alert("Excel library (XLSX) is not available.");
    return;
  }

  var ctx = window.WE_CTX;
  if (!ctx) {
    alert("No dataset loaded (WE_CTX missing).");
    return;
  }

  var wb = XLSX.utils.book_new();

  function addAoaSheet(name, aoa) {
    if (!aoa || !aoa.length) return;
    var ws = XLSX.utils.aoa_to_sheet(aoa);
    XLSX.utils.book_append_sheet(wb, ws, name);
  }

  // ---------------- _Meta ----------------
  if (ctx.META) {
    var m = ctx.META;
    var metaAoa = [
      ["Version", "ReleaseDate", "RevisionDate", "Copyright", "Notes", "AdminPW"],
      [
        m.version || "",
        exportMetaDateCell(m.releaseDate),
        exportMetaDateCell(m.revisionDate),      
        m.copyright || "",
        m.notes || "",
        m.adminPassword || ""
      ]
    ];
    addAoaSheet("_Meta", metaAoa);
  }

  // ---------------- _Topics ----------------
  var topicDefs = Array.isArray(ctx.TOPIC_DEFS) ? ctx.TOPIC_DEFS : [];
  var tipsById = ctx.TOPIC_TIPS_BY_ID || {};
  var topicsAoa = [["TopicID", "UI Label", "Tooltip", "SortOrder"]];

  topicDefs.forEach(function (t, idx) {
    var id, label;
    if (Array.isArray(t)) {
      id = t[0];
      label = t[1];
    } else {
      id = t.id || "";
      label = t.label || id;
    }
    var tip = tipsById && tipsById[id] ? tipsById[id] : "";
    var sortOrder = idx + 1;
    
    topicsAoa.push([id || "", label || "", tip || "", sortOrder]);
  });

  if (topicsAoa.length > 1) {
    addAoaSheet("_Topics", topicsAoa);
  }

  // ---------------- _Rows ----------------
  if (Array.isArray(ctx.ROWS)) {
    var rowsAoa = [["RowID", "UI Label", "Type", "Order", "RenderinBody", "HeaderFor"]];
    ctx.ROWS.forEach(function (r) {
      rowsAoa.push([
        r.id || "",
        r.label || "",
        r.type || "",
        (typeof r.order === "number" ? r.order : ""),
        r.renderInBody ? "Yes" : "No",
        r.headerFor || ""
      ]);
    });
    addAoaSheet("_Rows", rowsAoa);
  }

// ---------------- _States ----------------
var srcStates = Array.isArray(ctx.STATES_ALL) ? ctx.STATES_ALL : ctx.STATES;
if (Array.isArray(srcStates)) {
  var statesAoa = [
    ["State", "Abbreviation", "Order", "Enabled", "Implementation Date", "Revision Date"]
  ];
  srcStates.forEach(function (s) {
    statesAoa.push([
      s.name || "",
      s.code || "",
      (typeof s.order === "number" ? s.order : ""),
      s.enabled ? "Yes" : "No",
      exportMetaDateCell(s.implementedAt),
      exportMetaDateCell(s.revisionDate)
    ]);
  });
  addAoaSheet("_States", statesAoa);
}
// ---------------- FAQs ----------------
if (Array.isArray(ctx.FAQS)) {
  var faqsAoa = [
    [
      "State",
      "ID",
      "Question",
      "Answer",
      "Legal Authority",
      "Citation",
      "Sort",
      "Category1",
      "Category2",
      "Category3"
    ]
  ];

  // Extract the numeric FAQ number from an ID like "KY-Q23"
  function parseFaqNumber(id) {
    if (!id) return 0;
    var m = String(id).match(/Q(\d+)/i);
    return m ? parseInt(m[1], 10) : 0;
  }

  // Make a sorted copy of the FAQ list:
  //  1) by state code (alphabetical),
  //  2) then by FAQ number.
  var faqsSorted = ctx.FAQS.slice().sort(function (a, b) {
    var sa = String(a.state || "").toUpperCase();
    var sb = String(b.state || "").toUpperCase();
    if (sa !== sb) return sa.localeCompare(sb);

    var na = parseFaqNumber(a.id);
    var nb = parseFaqNumber(b.id);
    if (na !== nb) return na - nb;

    // tie-breaker: ID as text
    return String(a.id || "").localeCompare(String(b.id || ""));
  });

  var currentState = null;
  var perStateCounter = 0;

  faqsSorted.forEach(function (f) {
    var stateCode = String(f.state || "").toUpperCase();
    if (!stateCode) return;

    // Reset per-state counter when we move to a new state
    if (currentState !== stateCode) {
      currentState = stateCode;
      perStateCounter = 0;
    }
    perStateCounter += 1;

    // Categories may be an array or a single string
    var cats = [];
    if (Array.isArray(f.categories)) {
      cats = f.categories.slice(0, 3); // at most 3
    } else if (typeof f.categories === "string" && f.categories.trim() !== "") {
      cats = [f.categories.trim()];
    }

    var cat1 = cats[0] || "";
    var cat2 = cats[1] || "";
    var cat3 = cats[2] || "";

    faqsAoa.push([
      f.state || "",
      f.id || "",
      f.question || "",
      f.answer || "",
      f.authority || "",
      f.citation || "",
      perStateCounter, // Sort = order within that state
      cat1,
      cat2,
      cat3
    ]);
  });

  addAoaSheet("FAQs", faqsAoa);
}



  // ---------------- State sheets ----------------
  var entries = Array.isArray(ctx.ENTRIES) ? ctx.ENTRIES : [];
  var topicIds = topicDefs.map(function (t) {
    return Array.isArray(t) ? t[0] : (t.id || "");
  });

  // Map of state -> array of entries
  var byState = {};
  entries.forEach(function (e) {
    var code = String(e.state || e.State || "").toUpperCase();
    if (!code) return;
    if (!byState[code]) byState[code] = [];
    byState[code].push(e);
  });

  // Use explicit stateSheets list if present to preserve original order
  var stateSheets = Array.isArray(ctx.stateSheets)
    ? ctx.stateSheets.slice()
    : Object.keys(byState);

// All row IDs from ctx.ROWS (include non-render rows like 3a, 3b, 7)
var rowIds = [];
if (Array.isArray(ctx.ROWS)) {
  ctx.ROWS.forEach(function (r) {
    var id = String(r.id || "").trim();
    if (id && rowIds.indexOf(id) === -1) {
      rowIds.push(id);
    }
  });
}


  stateSheets.forEach(function (stateCodeRaw) {
    var stateCode = String(stateCodeRaw || "").toUpperCase();
    if (!stateCode) return;

    var entriesForState = byState[stateCode] || [];

    if (!entriesForState.length && !rowIds.length) {
      return; // nothing to write
    }

    var header = ["RowID"].concat(topicIds);
    var sheetAoa = [header];

    rowIds.forEach(function (rid) {
      var row = [rid];

      topicIds.forEach(function (tid) {
        var cellValue = "";
        // Find entry for this state & topic
        for (var i = 0; i < entriesForState.length; i++) {
          var ent = entriesForState[i];
          if (String(ent.topic || "") !== String(tid || "")) continue;
          if (!Array.isArray(ent.excerpts)) continue;
          for (var j = 0; j < ent.excerpts.length; j++) {
            var ex = ent.excerpts[j];
            if (String(ex.id || "") === String(rid || "")) {
              cellValue = ex.value || "";
              break;
            }
          }
          if (cellValue) break;
        }
        row.push(cellValue);
      });

      sheetAoa.push(row);
    });

    addAoaSheet(stateCode, sheetAoa);
  });

  // ---------------- EXTRA_SHEETS passthrough ----------------
// ---------------- EXTRA_SHEETS passthrough ----------------
if (ctx.EXTRA_SHEETS && typeof ctx.EXTRA_SHEETS === "object") {
  Object.keys(ctx.EXTRA_SHEETS).forEach(function (name) {
    var arr = ctx.EXTRA_SHEETS[name];
    if (!Array.isArray(arr) || !arr.length) return;
    try {
      var ws = XLSX.utils.json_to_sheet(arr);
      XLSX.utils.book_append_sheet(wb, ws, name);
    } catch (e) {
      console.warn("Could not export extra sheet:", name, e);
    }
  });
}



  // ---------------- Final write ----------------
  XLSX.writeFile(wb, "MasterLegalData_UPDATED.xlsx");
      // After a successful export, clear the "update needed" flag
      try {
        if (window.WE) {
          WE.ADMIN_UPDATE_NEEDED = false;
          if (typeof window.updateAdminExportButtonState === "function") {
            window.updateAdminExportButtonState();
          }
        }
      } catch (e) {
        console.warn("Reset ADMIN_UPDATE_NEEDED after export failed", e);
      }

};
</script>

    <!-- ------------------------------------------------------------
     PAGE FOOTER FOLLOWS (Copyright + Notes)
------------------------------------------------------------- -->
    <footer
      id="page-footer"
      style="
        text-align: center;
        padding: 12px 0;
        font-size: 13px;
        color: #666;
        border-top: 1px solid #ddd;
        margin-top: 40px;
      "
    ></footer>
  </body>
</html>
